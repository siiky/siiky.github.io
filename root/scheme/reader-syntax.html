
<h1>Reader Syntax</h1>
<p>@siiky
2022/03/15
2022/07/07</p>
<p>TIL a bit of reader syntax magic. With very few lines of code I was able to make available the #!sql reader syntax to let me read the contents of SQL files as a literal string (any file actually, but I was thinking of using it for SQL files only).</p>
<pre><code>; This:
#!sql &quot;path/to/file.sql&quot;
; Into this:
&quot;CREATE TABLE entries (\n    cid      TEXT        PRIMARY KEY NOT NULL UNIQUE,\n    name     TEXT        NOT NULL,\n    consumed BOOLEAN     NOT NULL DEFAULT FALSE,\n    url      TEXT        UNIQUE,\n    type     VARCHAR(10) NOT NULL REFERENCES types (name)\n);\n\nCREATE TABLE nodes (\n    id   TEXT        PRIMARY KEY NOT NULL UNIQUE,\n    name VARCHAR(20) UNIQUE\n);\n\nCREATE TABLE pins (\n    node TEXT NOT NULL REFERENCES nodes (id),\n    cid  TEXT NOT NULL REFERENCES entries (cid)\n);\n\nCREATE TABLE types (\n    name VARCHAR(10) PRIMARY KEY NOT NULL UNIQUE\n);\n&quot;
</code></pre>
<p>Here's the necessary code in its entirety:</p>
<pre><code>(set-read-syntax!
  'sql
  (lambda (port)
    (let ((path (read port)))
      (unless (string? path)
        (syntax-error &quot;The #!sql syntax expects a string&quot;))

      (let ((sql-stmt (call-with-input-file path (cute read-string #f &lt;&gt;) #:text)))
        (unless (string? sql-stmt)
          (syntax-error &quot;Failed reading the SQL file&quot;))
        sql-stmt))))
</code></pre>
<p>There's one caveat with this approach, however: the reader syntax will be available to the whole program, not just the file or module that defined or imported it. This means that the identifiers must be unique, otherwise different definitions will collide with each other and the compiled program won't be what you expect. AND I think that it will be available not only at compile time, but at runtime as well -- very good to keep in mind!</p>
<p>Someone on IRC mentioned that it's possible to use -extend (-X) to make it available at compile time only. As an example, they said that compiling with -X srfi-19-literals would allow one to write #@1-1-22. Try this, after installing SRFI-19:</p>
<pre><code>csi -R srfi-19 -R srfi-19-literals -p &quot;#@`date +'%Y-%m-%d'`&quot;
</code></pre>
<p>Relevant CHICKEN documentation for set-read-syntax! &amp; friends:</p>
<ul>
<li><a href="https://wiki.call-cc.org/man/5/Module%20(chicken%20read-syntax)">https://wiki.call-cc.org/man/5/Module%20(chicken%20read-syntax)</a></li>
<li><a href="https://api.call-cc.org/5/doc/chicken/read-syntax">https://api.call-cc.org/5/doc/chicken/read-syntax</a></li></ul>
<p>And the relevant SRFI-19 literals documentation:</p>
<ul>
<li><a href="https://wiki.call-cc.org/eggref/5/srfi-19#date-literal-form">https://wiki.call-cc.org/eggref/5/srfi-19#date-literal-form</a></li>
<li><a href="https://api.call-cc.org/5/doc/srfi-19/date-literal-form">https://api.call-cc.org/5/doc/srfi-19/date-literal-form</a></li></ul>
<hr />
<p>To make it more obvious why this is cool, here goes a slightly more realistic, though still simple, example.</p>
<p>Let's say we have these SQL files:</p>
<pre><code>-- schema.sql
CREATE TABLE sometbl (col TINYINT NOT NULL);

-- data.sql
INSERT INTO sometbl (col) VALUES (0),(1),(2),(3),(4),(5);

-- select.sql
SELECT rowid, col FROM sometbl;
</code></pre>
<p>An example.scm:</p>
<pre><code>(import sql-de-lite)

(define-constant schema #!sql&quot;schema.sql&quot;)
(define-constant data #!sql&quot;data.sql&quot;)
(define-constant select #!sql&quot;select.sql&quot;)

(print (call-with-database
         'memory
         (lambda (db)
           (let ((schema (sql db schema))
                 (data (sql db data))
                 (select (sql db select)))
             (query fetch-all schema)
             (query fetch-all data)
             (query fetch-all select)))))
</code></pre>
<p>And the set-read-syntax! call from before wrapped up in a module sql-reader-syntax. After compiling the module you can compile the example with csc -X sql-reader-syntax example.scm, and this is the result of running it:</p>
<pre><code>$ ./example
((1 0) (2 1) (3 2) (4 3) (5 4) (6 5))
</code></pre>
<p>The example.scm is basically transformed into this before being compiled:</p>
<pre><code>(import sql-de-lite)

(define-constant schema &quot;CREATE TABLE sometbl (col TINYINT NOT NULL);&quot;)
(define-constant data &quot;INSERT INTO sometbl (col) VALUES (0),(1),(2),(3),(4),(5);&quot;)
(define-constant select &quot;SELECT rowid, col FROM sometbl;&quot;)

(print (call-with-database
         'memory
         (lambda (db)
           (let ((schema (sql db schema))
                 (data (sql db data))
                 (select (sql db select)))
             (query fetch-all schema)
             (query fetch-all data)
             (query fetch-all select)))))
</code></pre>
<p>And notice how schema, data, and select are constants (defined with define-constant, kinda similar to the static keyword in C).</p>