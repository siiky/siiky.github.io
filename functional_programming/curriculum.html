<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="siiky" />
  <title>Curriculum for the Imperative vs Functional Programming Teaching Experiment</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">
body {
background-color:#101010;
color:#FD971F;
font-family:monospace;
font-size:15px;

}
h1,h2,h3,h4,h5,h6 {
color:#A6E22E;
text-decoration:bold;
}
h1 { font-size:21px; }
h2 { font-size:20px; }
h3 { font-size:19px; }
h4 { font-size:18px; }
h5 { font-size:17px; }
h6 { font-size:16px; }
a {
color:#66D9EF;
text-decoration:none
}
a:visited {
color:#A6E22E
}
a:hover {
background-color:#66D9EF;
color:#101010;
text-decoration:underline
}
</style>
</head>
<body>
<h1 id="nothing-interesting-here">nothing interesting here</h1>
<header id="title-block-header">
<h1 class="title">Curriculum for the Imperative vs Functional Programming Teaching Experiment</h1>
<p class="author">siiky</p>
<p class="date">2021/05/25</p>
</header>
<p>You can find this document in <a href="./curriculum.html">HTML</a>, <a href="./curriculum.pdf">PDF</a>, and the original <a href="./curriculum.org">Org</a>.</p>
<h1 data-number="1" id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p>The functional paradigm has many advantages over other more common, popular, and &quot;traditional&quot; paradigms, which are more popular to the detriment of the programmers using them, the functional programmers forced to use them, and the world at large, because the functional style is deemed to be complicated, hard to learn, understand, use, and targeted only at academic researchers.</p>
<p>This document will outline the curriculum for an experiment with the end goal of asserting whether the functional paradigm is indeed more difficult to learn, use, or understand, when compared to the imperative/procedural paradigm.</p>
<p>The experiment is somewhat biased towards the functional approach, and after the basic concepts that are common to all paradigms, those concepts that don&#39;t actually relate to programming itself, almost all concepts come from the functional world. As such, the imperative style taught will not be idiomatic imperative style, but bent to fit the functional style.</p>
<h1 data-number="2" id="the-languages"><span class="header-section-number">2</span> The Languages</h1>
<p>Due to the purpose of the experiment, and the target learners, the languages given as alternatives should satisfy these requisites:</p>
<ul>
<li><p>Should be high-level – no knowledge of the inner workings of a computer, of memory, of memory management, etc, should be required to use it effectively – C, C++, and similar are out of the question.</p></li>
<li><p>No program structure required – requiring a program in its entirety to live inside an artificial block is insane! – Java, C#, and similar are out of the question.</p></li>
<li><p>A REPL is a <strong>big</strong> plus! It facilitates and encourages experimentation with the language.</p></li>
</ul>
<p>A learner&#39;s choice of languages must consist of <em>at least</em> one language of each of the paradigms.</p>
<p>For the purpose of the experiment, Haskell will be required. As such, it will be used and assumed throughout this text in examples, due to it being strongly typed and so straightforward in this regard.</p>
<p>Here follow ideas/suggestions for possibly good language options.</p>
<h2 data-number="2.1" id="imperative"><span class="header-section-number">2.1</span> Imperative</h2>
<h3 data-number="2.1.1" id="python"><span class="header-section-number">2.1.1</span> Python</h3>
<p>Possibly the easiest of the listed imperative languages, used mostly in science. Has lots of magic.</p>
<h3 data-number="2.1.2" id="lua"><span class="header-section-number">2.1.2</span> Lua</h3>
<p>Very simple, small, and fast interpreted language, used a lot on game development and as an embedded language. No magic whatsoever.</p>
<h3 data-number="2.1.3" id="go"><span class="header-section-number">2.1.3</span> <span class="todo TODO">TODO</span> Go?</h3>
<p>The most difficult of the three, but also possibly the fastest, useful for concurrent systems. No magic. The only language of all of the listed in this document with no REPL.</p>
<h3 data-number="2.1.4" id="pascal"><span class="header-section-number">2.1.4</span> <span class="todo TODO">TODO</span> Pascal?</h3>
<h2 data-number="2.2" id="functional"><span class="header-section-number">2.2</span> Functional</h2>
<h3 data-number="2.2.1" id="haskell"><span class="header-section-number">2.2.1</span> Haskell</h3>
<p>A must due to its type system. Not much magic.</p>
<h3 data-number="2.2.2" id="scheme"><span class="header-section-number">2.2.2</span> Scheme</h3>
<p>Very simple general-purpose language with advanced meta programming, mainly due to its straightforward syntax. No magic whatsoever.</p>
<h3 data-number="2.2.3" id="elixir"><span class="header-section-number">2.2.3</span> Elixir</h3>
<p>Powerful language that runs on the <em>BEAM</em> VM, suited for parallel systems, with an actor model for its concurrency model. Brings lots of new features to the Erlang table, including proper modules and modules hierarchy, a decent polymorphic system, meta programming capabilities, and good tooling. Not much magic.</p>
<h1 data-number="3" id="programming"><span class="header-section-number">3</span> Programming</h1>
<h2 data-number="3.1" id="basic-types"><span class="header-section-number">3.1</span> Basic types</h2>
<p>The types that we will call <em>basic</em> are types provided by the base language. These vary between languages, but there&#39;s usually a set of <em>basic types</em> shared by most programming languages. Here we will cover the most common types that are available to all the languages discussed above.</p>
<h3 data-number="3.1.1" id="atomics"><span class="header-section-number">3.1.1</span> Atomics</h3>
<p>These are so called <em>atomics</em> because they cannot usally be <em>decomposed</em> in smaller parts. With these alone it&#39;s already possible to get a lot out of any programming language.</p>
<ol>
<li><p>Numbers</p>
<p>Nothing to explain here, other than that in computer programming languages it&#39;s common for integer numbers to be a distinct type from the <em>non</em>-integer numbers – such as <em>rationals</em>, <em>reals</em>, and <em>complex</em>.</p>
<p>In truth, a computer cannot represent <em>real</em> numbers, only approximations. The details aren&#39;t important – just keep in mind that when doing number calculations with reals on a computer, if you get unexpected results, it&#39;s very likely for this to be the cause.</p>
<p>The reasons to call non-integer numbers reals are that a computer may still be useful to do calculations on (approximate) reals, and that most programming languages don&#39;t have exact rational numbers – they just &quot;fake&quot; it.</p>
<ol>
<li><p>Integers</p>
<p>Just what one would expect – some examples:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="dv">0</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="dv">21</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="dv">42</span></span></code></pre></div>
<p>Some languages provide <em>unsigned</em> integer types, i.e., the naturals (including <code>0</code>), non-negative integers.</p></li>
<li><p>Reals</p>
<p>Mostly what one would expect as well:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="dv">0</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="dv">1</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="fl">3.14</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="op">-</span><span class="fl">6.28</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="fl">1.4142135</span></span></code></pre></div>
<p>Notation similar to the <em>scientific notation</em> is also common on many languages, but the exact notation differs between languages, so we won&#39;t detail it too much. However, they usually go something like this: <code>0.1234e5</code> is the same as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.1234</mn><mo>*</mo><msup><mn>10</mn><mn>5</mn></msup></mrow><annotation encoding="application/x-tex">0.1234*10^5</annotation></semantics></math>. Check the official documentation of each language for the exact supported notations.</p></li>
</ol></li>
<li><p>Booleans</p>
<p>Used for logic – <code>True</code> and <code>False</code>. The exact words or symbols used in each language varies, but these are common enough to be good guesses.</p></li>
<li><p>Chars?</p>
<p>Characters are values that may represent a letter, a number, a symbol, etc, such as: <code>&#39;a&#39;</code>, <code>&#39;3&#39;</code>, <code>&#39;!&#39;</code>, etc. Exact details vary wildly between languages too, so check the language&#39;s official documentation.</p>
<p>The most common notation is the one used above – surrounding the character with a single quote (<code>&#39;</code>).</p></li>
</ol>
<h3 data-number="3.1.2" id="sequences"><span class="header-section-number">3.1.2</span> Sequences</h3>
<p>These types are <em>collections</em> of other types, atomic or not, with an order, and they may be empty.</p>
<ol>
<li><p>Strings</p>
<p>These are sequences of characters. Examples of strings are <code>&quot;hello&quot;</code>, <code>&quot;0 + 1 =
2&quot;</code>, <code>&quot;&quot;</code>.</p>
<p>Although other notations exist, the most common of all is surrounding the characters of the string with double quotes (<code>&quot;</code>), like in the examples above.</p>
<p>This poses a problem, because by using double quotes to denote a string, makes it impossible to use double quotes themselves inside the string. To fix this, languages allow programmers to <em>escape</em> certain specific characters inside a string, by placing a single backslash (<code>\</code>) right before the character that&#39;s to be escaped – like this, a string with a single character, the double quote itself: <code>&quot;\&quot;&quot;</code>; or this: <code>&quot;And then they said: \&quot;are you gonna escape or
not?\&quot;&quot;</code>.</p>
<p>In Haskell, strings are actually just lists of characters, so the following section also applies to strings.</p></li>
<li><p>Lists/Arrays</p>
<p>These, in a way, can be thought of as a generalization of strings, but for elements other than characters. If a string is a list or array of characters, or something else entirely, depends on the language. However, such details aren&#39;t usually matter for concern.</p>
<p>Again, notation varies wildly between languages, but the most common among the languages discussed previously (about half of them) is surrounding the elements with square brackets (<code>[]</code>), and separating the elements with commas (<code>,</code>).</p>
<p>Some examples follow:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>[]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="op">-</span><span class="dv">4</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>[<span class="ch">&#39;h&#39;</span>, <span class="ch">&#39;e&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>[<span class="fl">3.14</span>, <span class="op">-</span><span class="fl">6.28</span>, <span class="fl">1.4142135</span>]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>[<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;there&quot;</span>]</span></code></pre></div></li>
<li><p><span class="todo TODO">TODO</span> Tuples?</p></li>
</ol>
<h2 data-number="3.2" id="basic-operations-on-basic-types"><span class="header-section-number">3.2</span> Basic operations on basic types</h2>
<p>Now that you know how to create, define, write, read, and understand the basic types, you&#39;re ready to get your hands dirty and do something with them.</p>
<h3 data-number="3.2.1" id="atomics-1"><span class="header-section-number">3.2.1</span> Atomics</h3>
<ol>
<li><p>Numbers</p>
<ol>
<li><p>Arithmetic</p>
<p>Possibly the thing numbers are most useful for. All (almost) of the arithmetic operations you&#39;re already familiar with from mathematics are available, and most basic with familiar names too: <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code>. Precedence is also the most common in mathematics: <code>*</code> and <code>/</code> take precedence over <code>+</code> and <code>-</code>; but otherwise, operations are applied from left to right. Nonetheless, it&#39;s possible to force operation precedence and clarify ambiguities with parentheses (<code>()</code>).</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="dv">21</span> <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a><span class="dv">66</span> <span class="op">/</span> <span class="dv">3</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="dv">2</span> <span class="op">*</span> <span class="dv">2</span> <span class="op">-</span> <span class="dv">3</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="dv">2</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">-</span> <span class="dv">3</span>)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>(<span class="dv">2</span> <span class="op">*</span> <span class="dv">2</span>) <span class="op">-</span> <span class="dv">3</span></span></code></pre></div></li>
</ol></li>
<li><p>Booleans</p>
<ol>
<li><p>Logic</p>
<p>The most basic logical operators from mathematics are also available: <em>not</em> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>¬</mi><annotation encoding="application/x-tex">\lnot</annotation></semantics></math>, <code>not</code>), <em>and</em> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo><annotation encoding="application/x-tex">\land</annotation></semantics></math>, <code>&amp;&amp;</code>), <em>or</em> (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∨</mo><annotation encoding="application/x-tex">\lor</annotation></semantics></math>, <code>||</code>). The order of precedence, from the most precedent to the least one is <code>not</code>, <code>&amp;&amp;</code>, <code>||</code>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="dt">True</span> <span class="op">||</span> <span class="dt">False</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="fu">not</span> <span class="dt">False</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="dt">True</span> <span class="op">&amp;&amp;</span> <span class="dt">True</span></span></code></pre></div>
<p>A note on implementation details: most programming languages evaluate both arithmetic and logical operators from left to right. However, computers are at essence sequential machines, and therefore cannot compute the value of two expressions simultaneously (a bit of a stretch here). Because of this, and for performance reasons, apart from <code>not</code> which is unary, logical operators are <em>short circuiting</em> – this is just a fancy way of saying that it&#39;ll try to do the least amount of work to get to the resulting value. This <em>short circuiting</em> is possible in these two cases:</p>
<ul>
<li><code>False &amp;&amp; B</code>, which evaluates to <code>False</code></li>
<li><code>True || B</code>, which evaluates to <code>True</code></li>
</ul>
<p>It may sound like a small detail, but it&#39;s actually an important one. And depending on the language, the operands&#39; order may actually change the program&#39;s behavior!</p></li>
</ol></li>
</ol>
<h3 data-number="3.2.2" id="sequences-1"><span class="header-section-number">3.2.2</span> Sequences</h3>
<ol>
<li><p>Indexing</p>
<p>In Haskell, to index a list (consequently strings too) you use the <code>!!</code> function – indexes start at 0:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] <span class="op">!!</span> <span class="dv">2</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span> <span class="op">!!</span> <span class="dv">4</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>[[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>], [<span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>]] <span class="op">!!</span> <span class="dv">1</span> <span class="op">!!</span> <span class="dv">1</span></span></code></pre></div></li>
<li><p>Destructuring</p>
<p>Lists are defined as either being empty (<code>[]</code>), or having a <em>head</em> and a <em>tail</em>, where the <em>head</em> is an element of the list, and the <em>tail</em> is the rest of the list. So, in order to destruct (i.e., separate) a list in its components, you use the creatively named functions <code>head</code> and <code>tail</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="fu">head</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="fu">tail</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="fu">head</span> <span class="st">&quot;hello&quot;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="fu">tail</span> <span class="st">&quot;hello&quot;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="fu">head</span> (<span class="fu">tail</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="fu">tail</span> (<span class="fu">tail</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span></code></pre></div>
<p>Given that we can <em>destruct</em> a list into both its components, we should also be able to <em>construct</em> a list given its components – and that&#39;s what we&#39;ll learn now. You can construct a list with its so-called <em>constructors</em>. As mentioned above, a list can be the empty list, or a <em>head</em> and a <em>tail</em> put together. So we need a way to create an empty list, and a way to create a list from its <em>head</em> and its <em>tail</em>.</p>
<p>The empty list is easy, because it is itself – <code>[]</code> is the empty list, there&#39;s no need to complicate.</p>
<p>And to put a <em>head</em> and a <em>tail</em> together to form a new list you can use the <em>cons</em> operator <code>(:)</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>[]</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>(<span class="op">:</span>) <span class="dv">1</span> []</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="dv">1</span><span class="op">:</span>[]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="dv">1</span><span class="op">:</span>(<span class="dv">2</span><span class="op">:</span>(<span class="dv">3</span><span class="op">:</span>[]))</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a><span class="dv">1</span><span class="op">:</span><span class="dv">2</span><span class="op">:</span><span class="dv">3</span><span class="op">:</span>[]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>[]<span class="op">:</span>[]</span></code></pre></div>
<p>What you saw above with <code>(:)</code> is an important Haskell convention to keep in mind. A function (or operator) that&#39;s defined (called) as <code>(fun)</code> (notice the parentheses) is an <em>infix</em> operator, i.e., it&#39;s placed in between the operands; while usually, for example with <code>head</code> and <code>tail</code>, functions are <em>prefix</em>, i.e., they&#39;re placed before the operands. The most common examples of <em>infix</em> operators are the arithmetic operators (<code>(+)</code>, <code>(/)</code>, etc). To turn an <em>infix</em> operator into a <em>prefix</em> operator, all you have to do is surround the operator with parentheses. So, <code>(+) 1 2</code> is the same as <code>1 + 2</code>.</p>
<p>There&#39;s also a convention to turn <em>prefix</em> operators into <em>infix</em> operators, which is to surround the operator with backticks (<code>`</code>) – we don&#39;t have an example yet, but it goes like this: <code>op arg1 arg2</code> is equivalent to <code>arg1 `op` arg2</code>. Later on we&#39;ll get to see examples of this.</p></li>
<li><p>Concatenation</p>
<p>The operation that takes two sequences of the same type and &quot;glues&quot; them together is called <em>concatenation</em>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>[<span class="dv">0</span>, <span class="dv">1</span>] <span class="op">++</span> [<span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>(<span class="op">++</span>) [<span class="dv">0</span>, <span class="dv">1</span>] [<span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="st">&quot;hello&quot;</span> <span class="op">++</span> <span class="st">&quot; &quot;</span> <span class="op">++</span> <span class="st">&quot;world&quot;</span></span></code></pre></div></li>
<li><p><span class="todo TODO">TODO</span> Interpolation?</p></li>
</ol>
<h3 data-number="3.2.3" id="order-comparison-equality-etc"><span class="header-section-number">3.2.3</span> Order – comparison, equality, etc</h3>
<p>Something else that&#39;s common in mathematics is comparing or equating things. For example, we can say that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>&lt;</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">2 &lt; 3</annotation></semantics></math>, that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2 + 2 = 4</annotation></semantics></math>, that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>⋅</mo><mn>3</mn><mo>&gt;</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">3 \cdot 3 &gt; 3</annotation></semantics></math>, that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>1</mn><mo>≠</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 + 1 \neq 1</annotation></semantics></math>, etc. When programming, being able to compare and equate things is also very useful. So here&#39;s the table:</p>
<table>
<thead>
<tr class="header">
<th>Mathematics</th>
<th>Haskell</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>&lt;</mo><annotation encoding="application/x-tex">&lt;</annotation></semantics></math></td>
<td><code>&lt;</code></td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>&gt;</mo><annotation encoding="application/x-tex">&gt;</annotation></semantics></math></td>
<td><code>&gt;</code></td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≤</mo><annotation encoding="application/x-tex">\le</annotation></semantics></math></td>
<td><code>&lt;=</code></td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≥</mo><annotation encoding="application/x-tex">\ge</annotation></semantics></math></td>
<td><code>&gt;=</code></td>
</tr>
<tr class="odd">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>=</mo><annotation encoding="application/x-tex">=</annotation></semantics></math></td>
<td><code>==</code></td>
</tr>
<tr class="even">
<td><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>≠</mo><annotation encoding="application/x-tex">\neq</annotation></semantics></math></td>
<td><code>/=</code></td>
</tr>
</tbody>
</table>
<p>The reason to use <code>==</code> instead of <code>=</code> for equality will be clear next.</p>
<h2 data-number="3.3" id="pure-numerical-functions-sn---sm"><span class="header-section-number">3.3</span> (Pure) Numerical Functions – S<sup>n</sup> -&gt; S<sup>m</sup></h2>
<p>Let&#39;s start now defining our own functions. A very high-level and hand-wavy way to explain is: whenever you would write <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>e</mi><mi>x</mi><mi>p</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">f(x) = expr</annotation></semantics></math>, in Haskell you translate that by writing <code>f x = expr</code>. So, for example, to define the <em>identity</em> function, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>t</mi><mi>y</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">identity(x) = x</annotation></semantics></math>, in Haskell, you just write <code>identity x = x</code>. For multivariable functions, you just need to add the parentheses in Haskell: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>x</mi><mo>⋅</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">f(x, y) = x \cdot y</annotation></semantics></math> translates to <code>f (x, y) = x * y</code>; <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>y</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(x, y) = (y, x)</annotation></semantics></math> translates to <code>f (x, y) = (y, x)</code>; <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(x) = (x, x)</annotation></semantics></math> translates to <code>f x = (x, x)</code>.</p>
<h3 data-number="3.3.1" id="doubles"><span class="header-section-number">3.3.1</span> Doubles</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>double x <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> x</span></code></pre></div>
<h3 data-number="3.3.2" id="squares"><span class="header-section-number">3.3.2</span> Squares</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>square x <span class="ot">=</span> x <span class="op">*</span> x</span></code></pre></div>
<h3 data-number="3.3.3" id="etc"><span class="header-section-number">3.3.3</span> etc</h3>
<h3 data-number="3.3.4" id="function-composition"><span class="header-section-number">3.3.4</span> Function composition</h3>
<p>Like in mathematics (calculus), it&#39;s possible to compose functions to define a new function. The notation is similar, and so are the semantics: <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo>∘</mo><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(f \circ
g)(x)</annotation></semantics></math> is the same as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>g</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(g(x))</annotation></semantics></math>. And in Haskell:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="co">-- double_square x = double (square x)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>double_square <span class="ot">=</span> double <span class="op">.</span> square</span></code></pre></div>
<p>As subtly implied at the beginning of this section, in the case of multivariable functions, composition also <em>just works</em>, as long as the types match.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>h x <span class="ot">=</span> (x, x <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>g (x, y) <span class="ot">=</span> (x <span class="op">*</span> <span class="dv">3</span>, y <span class="op">*</span> <span class="dv">2</span>, x <span class="op">+</span> y)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>f (x, y, z) <span class="ot">=</span> x <span class="op">*</span> y <span class="op">+</span> z</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>k <span class="ot">=</span> f <span class="op">.</span> g <span class="op">.</span> h</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>k <span class="dv">10</span></span></code></pre></div>
<h2 data-number="3.4" id="pure-logical-functions"><span class="header-section-number">3.4</span> (Pure) Logical Functions</h2>
<p>Before <em>(Pure) Predicates on Numbers</em> for background.</p>
<p>This is going to be a packed section, with several important bits. Let&#39;s start with <em>flow control</em>.</p>
<h3 data-number="3.4.1" id="flow-control"><span class="header-section-number">3.4.1</span> Flow Control</h3>
<p>It sometimes may happen that we need or want a function to do different things depending on some condition. Imagine we&#39;re defining the <em>absolute</em> function, i.e., the function that given a (signed) number always returns a positive number, that is the input number itself, or its symmetric.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>b</mi><mi>s</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mo>−</mo><mi>x</mi></mtd><mtd columnalign="left"><mtext mathvariant="normal">if</mtext><mspace width="0.222em"></mspace><mi>x</mi><mo>&lt;</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi></mtd><mtd columnalign="left"><mtext mathvariant="normal">otherwise</mtext></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
abs(x) =
\begin{cases}
-x &amp; \text{if}\ x &lt; 0 \\
x  &amp; \text{otherwise} \\
\end{cases}
</annotation></semantics></math></p>
<p>In Haskell, the most basic statement we have for this is the <code>if then else</code>. We could translate the function above to this:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="fu">abs</span> x <span class="ot">=</span> <span class="kw">if</span> x <span class="op">&lt;</span> <span class="dv">0</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>        <span class="kw">then</span> <span class="op">-</span>x</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>        <span class="kw">else</span> x</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a><span class="co">-- Note that the line breaks aren&#39;t necessary; this is also OK:</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="fu">abs</span> x <span class="ot">=</span> <span class="kw">if</span> x <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="op">-</span>x <span class="kw">else</span> x</span></code></pre></div>
<p>This is already enough to get everything needing flow control done. However, with more clauses it quickly grows in size:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>f (x, y, z) <span class="ot">=</span> <span class="kw">if</span> cond1</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>              <span class="kw">then</span> expr1</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>              <span class="kw">else</span> <span class="kw">if</span> cond2</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>                   <span class="kw">then</span> expr2</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>                   <span class="kw">else</span> <span class="kw">if</span> cond3</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>                        <span class="kw">then</span> expr3</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>                        <span class="kw">else</span> <span class="kw">if</span> cond4</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a>                             <span class="kw">then</span> expr4</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a>                             <span class="kw">else</span> expr5</span></code></pre></div>
<p>This is hard to type, and when the expressions span several lines it gets hard to read and understand the code. To remediate this problem, we have <em>guards</em>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>f (x, y, z) <span class="co">-- Notice that there&#39;s no equal sign here!</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>  <span class="op">|</span> cond1 <span class="ot">=</span> expr1</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>  <span class="op">|</span> cond2 <span class="ot">=</span> expr2</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>  <span class="op">|</span> cond3 <span class="ot">=</span> expr3</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>  <span class="op">|</span> cond4 <span class="ot">=</span> expr4</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> expr5</span></code></pre></div>
<p>The conditions are evaluated one by one, in the order defined; if a condition evaluates to true, then the corresponding expression is evaluated and the result is returned as the function&#39;s result; otherwise the next condition is tried. This exactly like the <code>if then else</code> expressions before. Because of that, you should consider the order of the conditions when using guards.</p>
<p>The <code>otherwise</code> clause isn&#39;t necessary, but if all the different conditions don&#39;t correspond to all the possible &quot;states&quot;, that is, if it&#39;s possible for all of the conditions to be false, then the program will crash if there&#39;s no <code>otherwise</code> clause.</p>
<p>Next we&#39;ll learn about a major Haskell feature, available on many functional programming languages, but not as much in imperative languages.</p>
<h3 data-number="3.4.2" id="pattern-matching-and-function-clauses"><span class="header-section-number">3.4.2</span> Pattern Matching and Function Clauses</h3>
<p><em>Pattern matching</em> allows us to <em>match</em> values according to patterns. For example, if we were to define arithmetic operators, we should probably add one or more clauses to take care of 0 or 1, because they&#39;re usually &quot;special&quot;.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>u</mi><mi>l</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>,</mo><mi>y</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mtext mathvariant="normal">if</mtext><mspace width="0.222em"></mspace><mi>x</mi><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mn>0</mn></mtd><mtd columnalign="left"><mtext mathvariant="normal">if</mtext><mspace width="0.222em"></mspace><mi>y</mi><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>y</mi></mtd><mtd columnalign="left"><mtext mathvariant="normal">if</mtext><mspace width="0.222em"></mspace><mi>x</mi><mo>=</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left"><mi>x</mi></mtd><mtd columnalign="left"><mtext mathvariant="normal">if</mtext><mspace width="0.222em"></mspace><mi>y</mi><mo>=</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left"><mtext mathvariant="normal">The common case...</mtext></mtd><mtd columnalign="left"><mi>o</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>w</mi><mi>i</mi><mi>s</mi><mi>e</mi></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
mul(x, y) =
\begin{cases}
0 &amp; \text{if}\ x = 0 \\
0 &amp; \text{if}\ y = 0 \\
y &amp; \text{if}\ x = 1 \\
x &amp; \text{if}\ y = 1 \\
\text{The common case...} &amp; otherwise \\
\end{cases}
</annotation></semantics></math></p>
<p>We can already define an equivalent function in Haskell using either <code>if then
else</code> or guards:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>mul (x, y)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>  <span class="op">|</span> x <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  <span class="op">|</span> y <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  <span class="op">|</span> x <span class="op">==</span> <span class="dv">1</span> <span class="ot">=</span> y</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  <span class="op">|</span> y <span class="op">==</span> <span class="dv">1</span> <span class="ot">=</span> x</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>  <span class="co">-- `undefined` can be used to &quot;make holes&quot; when we don&#39;t know</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  <span class="co">-- how, or don&#39;t want, to define some expression.</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>And you might be able to guess that <em>pattern matching</em> (together with several function clauses) can be used to define this function even more succinctly:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>mul (<span class="dv">0</span>, y) <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>mul (x, <span class="dv">0</span>) <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>mul (<span class="dv">1</span>, y) <span class="ot">=</span> y</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>mul (x, <span class="dv">1</span>) <span class="ot">=</span> x</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>mul (x, y) <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>A function clause is analogous to a guard clause – each one will be tried in order, and the first one to &quot;work&quot; is chosen. Each of the clauses is composed of a <em>pattern</em>, and when the function is called, the arguments are matched with the pattern. If they do match, then the corresponding expression is evaluated, and the result is returned as the function&#39;s result. Otherwise, the next pattern is tried. Similar to the case of guards, if the arguments don&#39;t match any of the patterns, then an error is thrown.</p>
<p>One last tip on pattern matching: if you don&#39;t care about a particular value, you can give it the pattern <code>_</code>, which will match <em>anything</em>, but won&#39;t be given a name. Thus, the first two clauses of the <code>mul</code> function could be rewritten like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>mul (<span class="dv">0</span>, _) <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a>mul (_, <span class="dv">0</span>) <span class="ot">=</span> <span class="dv">0</span></span></code></pre></div>
<p>Pattern matching isn&#39;t limited to numbers, however – you can pattern match on values of any type. And that&#39;s what you&#39;ll practice next.</p>
<h3 data-number="3.4.3" id="not"><span class="header-section-number">3.4.3</span> NOT</h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>myNot <span class="dt">True</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>myNot <span class="dt">False</span> <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<h3 data-number="3.4.4" id="and"><span class="header-section-number">3.4.4</span> AND</h3>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>myAnd (<span class="dt">True</span>, <span class="dt">True</span>) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>myAnd (_, _) <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h3 data-number="3.4.5" id="or"><span class="header-section-number">3.4.5</span> OR</h3>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>myOr (<span class="dt">False</span>, <span class="dt">False</span>) <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>myOr (_, _) <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<h3 data-number="3.4.6" id="xor"><span class="header-section-number">3.4.6</span> XOR</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>myXor (<span class="dt">True</span>, <span class="dt">False</span>) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>myXor (<span class="dt">False</span>, <span class="dt">True</span>) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>myXor (_, _) <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h3 data-number="3.4.7" id="etc-1"><span class="header-section-number">3.4.7</span> etc</h3>
<h2 data-number="3.5" id="pure-predicates-on-numbers"><span class="header-section-number">3.5</span> (Pure) Predicates on Numbers</h2>
<h3 data-number="3.5.1" id="is-multiple-in-terms-of-division"><span class="header-section-number">3.5.1</span> Is multiple? – in terms of division</h3>
<h3 data-number="3.5.2" id="is-evenodd-in-terms-of-division"><span class="header-section-number">3.5.2</span> Is even/odd? – in terms of division</h3>
<h3 data-number="3.5.3" id="etc-2"><span class="header-section-number">3.5.3</span> etc</h3>
<h2 data-number="3.6" id="pure-predicates-on-chars"><span class="header-section-number">3.6</span> (Pure) Predicates on Chars?</h2>
<h3 data-number="3.6.1" id="is-number"><span class="header-section-number">3.6.1</span> Is number?</h3>
<h3 data-number="3.6.2" id="is-alpha"><span class="header-section-number">3.6.2</span> Is alpha?</h3>
<h3 data-number="3.6.3" id="is-symbol"><span class="header-section-number">3.6.3</span> Is symbol?</h3>
<h3 data-number="3.6.4" id="etc-3"><span class="header-section-number">3.6.4</span> etc</h3>
<h2 data-number="3.7" id="pure-recursive-functions-on-numbers"><span class="header-section-number">3.7</span> (Pure) Recursive Functions on Numbers</h2>
<h3 data-number="3.7.1" id="is-evenodd"><span class="header-section-number">3.7.1</span> Is even/odd?</h3>
<h3 data-number="3.7.2" id="is-multiple"><span class="header-section-number">3.7.2</span> Is multiple?</h3>
<h3 data-number="3.7.3" id="sum-product-recursive-process"><span class="header-section-number">3.7.3</span> Sum, product, … – recursive process</h3>
<h3 data-number="3.7.4" id="fibonacci-the-mathematical-definition-recursive-process"><span class="header-section-number">3.7.4</span> Fibonacci – the mathematical definition (recursive process)</h3>
<h3 data-number="3.7.5" id="sum-product-iterative-process"><span class="header-section-number">3.7.5</span> Sum, product, … – iterative process</h3>
<h3 data-number="3.7.6" id="fibonacci-iterative-process"><span class="header-section-number">3.7.6</span> Fibonacci – iterative process</h3>
<h3 data-number="3.7.7" id="etc-4"><span class="header-section-number">3.7.7</span> etc</h3>
<h2 data-number="3.8" id="pure-functions-on-sequences"><span class="header-section-number">3.8</span> (Pure) Functions on Sequences</h2>
<h3 data-number="3.8.1" id="is-empty"><span class="header-section-number">3.8.1</span> Is empty?</h3>
<h3 data-number="3.8.2" id="has-member"><span class="header-section-number">3.8.2</span> Has member?</h3>
<h3 data-number="3.8.3" id="length-recursive-and-iterative-processes"><span class="header-section-number">3.8.3</span> Length – recursive and iterative processes</h3>
<h3 data-number="3.8.4" id="reverse-recursive-and-iterative-processes"><span class="header-section-number">3.8.4</span> Reverse – recursive and iterative processes</h3>
<h3 data-number="3.8.5" id="etc-5"><span class="header-section-number">3.8.5</span> etc</h3>
<h2 data-number="3.9" id="pure-functions-over-sequences"><span class="header-section-number">3.9</span> (Pure) Functions over Sequences</h2>
<p>With explicit recursion.</p>
<h3 data-number="3.9.1" id="double-add-1"><span class="header-section-number">3.9.1</span> Double, add 1, …</h3>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>double [] <span class="ot">=</span> []</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>double (h<span class="op">:</span>t) <span class="ot">=</span> (<span class="dv">2</span> <span class="op">*</span> h)<span class="op">:</span>(double t)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>add1 [] <span class="ot">=</span> []</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>add1 (h<span class="op">:</span>t) <span class="ot">=</span> (h <span class="op">+</span> <span class="dv">1</span>)<span class="op">:</span>(add1 t)</span></code></pre></div>
<h3 data-number="3.9.2" id="sum-product"><span class="header-section-number">3.9.2</span> <code>sum</code>, <code>product</code>, …</h3>
<h2 data-number="3.10" id="pure-functions-over-sequences-higher-order-functions"><span class="header-section-number">3.10</span> (Pure) Functions over Sequences (Higher-order Functions)</h2>
<p>Using higher-order functions.</p>
<h3 data-number="3.10.1" id="map-double-add-1-triple"><span class="header-section-number">3.10.1</span> <code>map</code> – double, add 1, triple, …</h3>
<h3 data-number="3.10.2" id="fold-length-reverse-has-member"><span class="header-section-number">3.10.2</span> <code>fold</code> – length, reverse, has member?, …</h3>
<h3 data-number="3.10.3" id="map-in-terms-of-fold"><span class="header-section-number">3.10.3</span> <code>map</code> in terms of <code>fold</code></h3>
<div class="line-block">places:<br />
<a href="https://siiky.github.io">Go home!</a><br />
<a href="https://github.com/siiky">GitHub</a><br />
<a href="https://siiky.github.io/atom.xml">Atom Feed</a></div>
</body>
</html>
