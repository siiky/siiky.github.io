<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html lang="en" xml:lang="en"><head><meta charset="utf-8"></meta></head><body><h1>Category Theory and Performance</h1><p>siiky<br></br>2019/10/15<br></br>2022/07/14</p><p>Imagine for a second that we understand Category Theory. Now imagine that we have a fancy category, representing a part of a program, with two objects X and Y (representing the input and output types of our program respectively), and morphisms f : X → Y and g : Y → X (because this is a category). This is what we have:</p><ul><li><a href="ctp-cat.svg">Some category</a></li></ul><p>Imagine now that there&#39;s a (reasonable) way to determine if two morphisms are equal. That is, given f, g : X → Y, f and g are equal iff, ∀ x ∈ X: f(x) = g(x).</p><p>Imagine there&#39;s also a way to analyze performance of a given morphism. We&#39;ll represent the performance of a given morphism f as P(f). The lesser P(f) is, for any given morphism, the better.</p><p>From this category we&#39;ll generate a new one where the morphisms are annotated along with their performance. We&#39;ll represent an annotated morphism f as (f, P(f)). Like so:</p><ul><li><a href="ctp-cat-perf.svg">Some category w/ performance analysis</a></li></ul><p>Application of a morphism to an object and composition of morphisms ignores the right component of the tuple:</p><ul><li>(f, P(f))(x) = f(x)</li><li>(g, P(g)) • (f, P(f)) = (g•f, P(g•f))</li></ul><p>And thus, for this post, I&#39;ll say that &quot;two morphisms are equal&quot; to mean that the &quot;plain morphism&quot; is equal, that is, ignoring the right component of the tuples; and I&#39;ll say that &quot;two morphisms are the same&quot; when both components of the tuple are equal. Think of two different implementations of a certain abstract algorithm. Both implementations perform the same operation, but they&#39;re not the same implementation, they (may) have different properties. We&#39;re interested in performance here.</p><p>Some properties right away:</p><ul><li>Two equal morphisms do not necessarily have equal performance: ¬(f = g ⇒ P(f) = P(g)).</li><li>Two morphisms with the same performance aren&#39;t necessarily equal: ¬(P(f) = P(g) ⇒ f = g)</li><li>Two morphisms with different performance aren&#39;t necessarily different: ¬(P(f) ≠ P(g) ⇒ f ≠ g)</li></ul><p>The latter two don&#39;t add much to our toolbox.</p><p>Now, from our original category, we&#39;ll forsake g, because who cares, and we&#39;ll add to it a morphism h equal to f.</p><ul><li><a href="ctp-cat-perf-h.svg">Category w/ performance analysis &amp; h</a></li></ul><p>Because f = h, improving the performance of our program, without changing its results, consists in choosing the morphism with better performance. If P(f) &lt; P(h), choose f; if P(h) &lt; P(f), choose h; otherwise, ask your mirror for the prettier of the two.</p><p>&quot;What&#39;s this all good for?&quot; you may ask! Nothing, really, if you don&#39;t use it. We like imagining, so we&#39;ll do it once more: there&#39;s a complicated (imaginary) category representing our complicated (imaginary) program, with performance annotations. The program takes an input I and transforms it into some output O. For simplicity, we&#39;ll only represent the most performant morphism between each two objects.</p><ul><li><a href="ctp-complicated-cat.svg">Complicated Category</a></li></ul><p>Omitted labels because they clutter too much. {X, Y, Z, W} form a complete graph. Now finding the most performant way to write our program is finding the shortest weighted path between I and O, with the performance as the weight. The hardest part is coming up with different implementations and analyzing their performance, really, because even a computer can find the best way to optimize the program!</p><ul><li><a href="https://en.wikipedia.org/wiki/Category_theory">Category Theory</a></li><li><a href="https://en.wikipedia.org/wiki/Category_(mathematics)">Category</a></li></ul></body></html>