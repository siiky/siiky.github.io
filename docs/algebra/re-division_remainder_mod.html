<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html lang="2023/06/18" xml:lang="2023/06/18"><head><meta charset="utf-8"></meta></head><body><h1>RE: Division, remainder, mod ➗%❓</h1><p>siiky<br></br>2023/06/18<br></br>2023/06/18<br></br>2023/06/18<br></br>en</p><ul><li><a href="https://portal.mozz.us/gemini/freeshell.de/gemlog/2023-06-18_Division__remainder__mod.gmi">Division, remainder, mod ➗%❓</a></li></ul><blockquote>I&#39;m not qualified to say if that&#39;s true (and I don&#39;t really care)</blockquote><p>Yes, you are qualified. You can tell whether -1 and 1 are the same number.</p><p>And yes, as a programmer, you should care. Integers are the most basic atomic data type in a computer. As programmers we have to deal with integers and do integer arithmetic all the time. Both remainder and modulo are useful (the latter more so than the former, in my experience), and knowing which one we have in hands can be the difference between the program we just wrote doing what we expected or crashing.</p><blockquote>Whitespace was originally implemented in Haskell, and I wrote an interpreter in Java. These two languages disagree on what the operator % means for negative inputs, so I read what Wikipedia has to say on the differrence.<br></br>Oh, wow! What a mess.</blockquote><p>There&#39;s no % operator in Haskell (AFAIK?), you usually either use rem or mod (an example of why you should care). And yeah, that Wikipedia page is not the friendliest...</p><blockquote>What integer do you round to if you can&#39;t divide exactly? Wikipedia lists FIVE ways to decide on the result, with graphs. Ouch.</blockquote><p>Right, again, that page is not the best... Those graphs are just confusing.</p><p>There&#39;s only one definition of &quot;remainder&quot;, the one based on Euclidean division. Both quotient and remainder are well defined functions, and easy to implement in any programming language too. The &quot;different ways&quot; are implementation details -- &quot;how&quot;, not &quot;what&quot;. However the integer division is implemented -- be it &quot;truncating&quot;, &quot;flooring&quot; or whatever else -- what matters is if the language implements the quotient, remainder, and modulo correctly.</p><blockquote>Once you&#39;ve decided how integer division works, then you can decide what % means. Good luck. You won&#39;t please everyone.</blockquote><p>There&#39;s only one integer division definition (see above), so you only need to set % to the remainder or the modulo. Which of the two you pick is largely unimportant and, as you say, won&#39;t please everyone -- hardly important either. And after that, only if you choose modulo do you have another decision to make.</p><p>(Fun fact: modulo is not a function, it&#39;s a relation. We talk as if it was a function to save our brains from melting.)</p><p>That&#39;s where the a choice comes from. For example, -5 ≣ -2 ≣ 1 ≣ 4 ≣ 7 ≣ 10 (mod 3) -- which of the relation &quot;outputs&quot; do you pick as the function result? There&#39;s a single one sane option (which defines the &quot;set of residues&quot;).</p><ul><li><a href="https://en.wikipedia.org/wiki/Modular_arithmetic#Residue_systems">https://en.wikipedia.org/wiki/Modular_arithmetic#Residue_systems</a></li></ul><blockquote>Math.floorMod() (...) does [what] siiky wanted.</blockquote><p>Indeed, that looks like what I need, thanks! Here&#39;s a (probably less efficient) alternative in case you only have the remainder to work with:</p><pre>n `mod` m = ((n `rem` m) + m) `rem` m
</pre><pre>(n % m + m) % m
</pre><pre>(remainder (+ (remainder n m) m) m)
</pre><blockquote>My practical advice is that remainder and mod are the same, except for negative numbers, where language implementers live in a wild, Bohemian, devil-may-care world, and do what they like.</blockquote><p>That&#39;s roughly correct, regarding remainder and modulo. The second part is largely correct too -- language implementers can do whatever the fuck they want... However, remember that there&#39;s only one remainder definition and an infinite number of modulo implementations, only one of which is sane. A serious language should use those.</p></body></html>