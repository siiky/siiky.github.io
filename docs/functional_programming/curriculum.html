<p>You can find this document in <a href="./curriculum.html">HTML</a>,
<a href="./curriculum.pdf">PDF</a>, and the original <a
href="./curriculum.org">Org</a>.</p>
<h1 id="introduction">Introduction</h1>
<p>The functional paradigm has many advantages over other more common,
popular, and "traditional" paradigms, which are more popular to the
detriment of the programmers using them, the functional programmers
forced to use them, and the world at large, because the functional style
is deemed to be complicated, hard to learn, understand, use, and
targeted only at academic researchers.</p>
<p>This document will outline the curriculum for an experiment with the
end goal of asserting whether the functional paradigm is indeed more
difficult to learn, use, or understand, when compared to the
imperative/procedural paradigm.</p>
<p>The experiment is somewhat biased towards the functional approach,
and after the basic concepts that are common to all paradigms, those
concepts that don't actually relate to programming itself, almost all
concepts come from the functional world. As such, the imperative style
taught will not be idiomatic imperative style, but bent to fit the
functional style.</p>
<h1 id="the-languages">The Languages</h1>
<p>Due to the purpose of the experiment, and the target learners, the
languages given as alternatives should satisfy these requisites:</p>
<ul>
<li><p>Should be high-level – no knowledge of the inner workings of a
computer, of memory, of memory management, etc, should be required to
use it effectively – C, C++, and similar are out of the
question.</p></li>
<li><p>No program structure required – requiring a program in its
entirety to live inside an artificial block is insane! – Java, C#, and
similar are out of the question.</p></li>
<li><p>A REPL is a <strong>big</strong> plus! It facilitates and
encourages experimentation with the language.</p></li>
</ul>
<p>A learner's choice of languages must consist of <em>at least</em> one
language of each of the paradigms.</p>
<p>For the purpose of the experiment, Haskell will be required. As such,
it will be used and assumed throughout this text in examples, due to it
being strongly typed and so straightforward in this regard.</p>
<p>Here follow ideas/suggestions for possibly good language options.</p>
<h2 id="imperative">Imperative</h2>
<h3 id="python">Python</h3>
<p>Possibly the easiest of the listed imperative languages, used mostly
in science. Has lots of magic.</p>
<h3 id="lua">Lua</h3>
<p>Very simple, small, and fast interpreted language, used a lot on game
development and as an embedded language. No magic whatsoever.</p>
<h3 id="go"><span class="todo TODO">TODO</span> Go?</h3>
<p>The most difficult of the three, but also possibly the fastest,
useful for concurrent systems. No magic. The only language of all of the
listed in this document with no REPL.</p>
<h3 id="pascal"><span class="todo TODO">TODO</span> Pascal?</h3>
<h2 id="functional">Functional</h2>
<h3 id="haskell">Haskell</h3>
<p>A must due to its type system. Not much magic.</p>
<h3 id="scheme">Scheme</h3>
<p>Very simple general-purpose language with advanced meta programming,
mainly due to its straightforward syntax. No magic whatsoever.</p>
<h3 id="elixir">Elixir</h3>
<p>Powerful language that runs on the <em>BEAM</em> VM, suited for
parallel systems, with an actor model for its concurrency model. Brings
lots of new features to the Erlang table, including proper modules and
modules hierarchy, a decent polymorphic system, meta programming
capabilities, and good tooling. Not much magic.</p>
<h1 id="programming">Programming</h1>
<p>First thing to know about Haskell is that it's strongly typed, which
means every value has a type, and the compiler/interpreter enforces
these types.</p>
<p>The syntax is similar to notation used in mathematics: an object
<span class="math inline"><em>x</em></span> of type <span
class="math inline"><em>A</em></span> is written <span
class="math inline"><em>x</em> : <em>A</em></span>; in Haskell it's
written <code>x :: A</code>. A function <span
class="math inline"><em>f</em></span> that given an <span
class="math inline"><em>A</em></span> calculates a <span
class="math inline"><em>B</em></span> is written <span
class="math inline"><em>f</em> : <em>A</em> → <em>B</em></span>; in
Haskell it's written <code>f :: A -&gt; B</code>. And so on…</p>
<p>In many cases Haskell can infer ("guess") the type of some value, so
specifying types is mostly optional. In these initial examples we will
keep the types explicit, but later we will ignore them, unless there's
good reason not to.</p>
<h2 id="basic-types">Basic types</h2>
<p>The types that we will call <em>basic</em> are types provided by the
base language. These vary between languages, but there's usually a set
of <em>basic types</em> shared by most programming languages. Here we
will cover the most common types that are available to all the languages
discussed above.</p>
<h3 id="atomics">Atomics</h3>
<p>These are so called <em>atomics</em> because they cannot usally be
<em>decomposed</em> in smaller parts. With these alone it's already
possible to get a lot out of any programming language.</p>
<ol>
<li><p>Numbers</p>
<p>Nothing to explain here, other than that in computer programming
languages it's common for integer numbers to be a distinct type from the
<em>non</em>-integer numbers – such as <em>rationals</em>,
<em>reals</em>, and <em>complex</em>.</p>
<p>In truth, a computer cannot represent <em>real</em> numbers, only
approximations. The details aren't important – just keep in mind that
when doing number calculations with reals on a computer, if you get
unexpected results, it's very likely for this to be the cause.</p>
<p>The reasons to call non-integer numbers reals are that a computer may
still be useful to do calculations on (approximate) reals, and that most
programming languages don't have exact rational numbers – they just fake
it.</p>
<ol>
<li><p>Integers</p>
<p>Just what one would expect – some examples:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dv">21</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span><span class="ot"> ::</span> <span class="dt">Int</span></span></code></pre></div>
<p>Some languages provide <em>unsigned</em> integer types, i.e., the
naturals (including <code>0</code>), non-negative integers.</p></li>
<li><p>Reals</p>
<p>Mostly what one would expect as well:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Float</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Float</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fl">3.14</span><span class="ot"> ::</span> <span class="dt">Float</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="fl">6.28</span><span class="ot"> ::</span> <span class="dt">Float</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="fl">1.4142135</span><span class="ot"> ::</span> <span class="dt">Float</span></span></code></pre></div>
<p>Notation similar to the <em>scientific notation</em> is also common
on many languages, but the exact notation differs between languages. We
won't be using it in this document, so we won't detail it here. However,
they usually go something like this: <code>0.1234e5</code> is the same
as <span class="math inline">0.1234 * 10<sup>5</sup></span>. Check the
official documentation of each language for the exact supported
notations.</p></li>
</ol></li>
<li><p>Booleans</p>
<p>Used for logic – <code>True</code> and <code>False</code>. The exact
words or symbols used in each language varies, but these are common
enough to be good guesses.</p></li>
<li><p>Chars?</p>
<p>Characters are values that may represent a letter, a number, a
symbol, etc, such as: <code>'a'</code>, <code>'3'</code>,
<code>'!'</code>, etc. Exact details vary wildly between languages too,
so check the language's official documentation.</p>
<p>The most common notation is the one used above – surrounding the
character with a single quote (<code>'</code>).</p></li>
</ol>
<h3 id="sequences">Sequences</h3>
<p>These types are <em>collections</em> of other types, atomic or not,
with an order, and they may be empty.</p>
<ol>
<li><p>Strings</p>
<p>These are sequences of characters. Examples of strings are
<code>"hello"</code>, <code>"0 + 1 =
2"</code>, <code>""</code>.</p>
<p>Although other notations exist, the most common of all is surrounding
the characters of the string with double quotes (<code>"</code>), like
in the examples above.</p>
<p>This poses a problem, because by using double quotes to denote a
string, makes it impossible to use double quotes themselves inside the
string. To fix this, languages allow programmers to <em>escape</em>
certain specific characters inside a string, by placing a single
backslash (<code>\</code>) right before the character that's to be
escaped – like this, a string with a single character, the double quote
itself: <code>"\""</code>; or this:
<code>"And then they said: \"are you gonna escape or
not?\""</code>.</p>
<p>In Haskell, strings are actually just lists of characters, so the
following section also applies to strings.</p></li>
<li><p>Lists/Arrays</p>
<p>These, in a way, can be thought of as a generalization of strings,
but for elements other than characters. If a string is a list or array
of characters, or something else entirely, depends on the language.
However, such details aren't usually matter for concern.</p>
<p>Again, notation varies wildly between languages, but the most common
among the languages discussed previously (about half of them) is
surrounding the elements with square brackets (<code>[]</code>), and
separating the elements with commas (<code>,</code>).</p>
<p>Some examples follow:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>[]<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>[]<span class="ot"> ::</span> [<span class="dt">Float</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>[]<span class="ot"> ::</span> [<span class="dt">Char</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;&quot;</span><span class="ot"> ::</span> [<span class="dt">Char</span>]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="op">-</span><span class="dv">4</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>, <span class="dv">2</span>, <span class="op">-</span><span class="dv">4</span>]<span class="ot"> ::</span> [<span class="dt">Float</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>[<span class="ch">&#39;h&#39;</span>, <span class="ch">&#39;e&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span>]<span class="ot"> ::</span> [<span class="dt">Char</span>]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>[<span class="ch">&#39;h&#39;</span>, <span class="ch">&#39;e&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;l&#39;</span>, <span class="ch">&#39;o&#39;</span>]<span class="ot"> ::</span> <span class="dt">String</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>[<span class="fl">3.14</span>, <span class="op">-</span><span class="fl">6.28</span>, <span class="fl">1.4142135</span>]<span class="ot"> ::</span> [<span class="dt">Float</span>]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;there&quot;</span>]<span class="ot"> ::</span> [[<span class="dt">Char</span>]]</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>[<span class="st">&quot;hello&quot;</span>, <span class="st">&quot;there&quot;</span>]<span class="ot"> ::</span> [<span class="dt">String</span>]</span></code></pre></div>
<p>Try to understand these type annotations; it will be useful later
on.</p></li>
<li><p><span class="todo TODO">TODO</span> Tuples?</p></li>
</ol>
<h2 id="basic-operations-on-basic-types">Basic operations on basic
types</h2>
<p>Now that you know how to create, define, write, read, and understand
the basic types, you're ready to get your hands dirty and do something
with them.</p>
<h3 id="atomics-1">Atomics</h3>
<ol>
<li><p>Numbers</p>
<ol>
<li><p>Arithmetic</p>
<p>Possibly the thing numbers are most useful for. All (almost) of the
arithmetic operations you're already familiar with from mathematics are
available, and most basic with familiar names too: <code>+</code>,
<code>*</code>, <code>-</code>, <code>/</code>. Precedence is also the
most common in mathematics: <code>*</code> and <code>/</code> take
precedence over <code>+</code> and <code>-</code>; but otherwise,
operations are applied from left to right. Nonetheless, it's possible to
force operation precedence and clarify ambiguities with parentheses
(<code>()</code>).</p>
<div class="captioned-content">
<div class="caption">
Examples of numbers
</div>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dv">21</span> <span class="op">*</span> <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dv">66</span> <span class="op">/</span> <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Float</span> <span class="co">-- Int doesn&#39;t work; why?</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">*</span> <span class="dv">2</span> <span class="op">-</span> <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">*</span> (<span class="dv">2</span> <span class="op">-</span> <span class="dv">3</span>)<span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span> <span class="op">*</span> <span class="dv">2</span>) <span class="op">-</span> <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Int</span></span></code></pre></div>
</div>
<p>All of the examples above work as well if you specify
<code>Float</code> as their type. [@lst:numbers]</p></li>
</ol></li>
<li><p>Booleans</p>
<ol>
<li><p>Logic</p>
<p>The most basic logical operators from mathematics are also available:
<em>not</em> (<span class="math inline">¬</span>, <code>not</code>),
<em>and</em> (<span class="math inline">∧</span>,
<code>&amp;&amp;</code>), <em>or</em> (<span
class="math inline">∨</span>, <code>||</code>). The order of precedence,
from the most precedent to the least one is <code>not</code>,
<code>&amp;&amp;</code>, <code>||</code>.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span> <span class="op">||</span> <span class="dt">False</span><span class="ot"> ::</span> <span class="dt">Bool</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">not</span> <span class="dt">False</span><span class="ot"> ::</span> <span class="dt">Bool</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="dt">True</span> <span class="op">&amp;&amp;</span> <span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span></span></code></pre></div>
<p>A note on implementation details: computers are at essence sequential
machines, and therefore cannot compute the value of two expressions
simultaneously (a bit of a stretch here). And most programming languages
evaluate arithmetic and logical expressions from left to right. Because
of this, and for performance reasons, apart from <code>not</code> which
is unary, logical operators are <em>short circuiting</em> – this is just
a fancy way of saying that it'll try to do the least amount of work to
get to the resulting value. This <em>short circuiting</em> is possible
in these two cases:</p>
<ul>
<li><code>False &amp;&amp; B</code>, which evaluates to
<code>False</code></li>
<li><code>True || B</code>, which evaluates to <code>True</code></li>
</ul>
<p>It may sound like a small detail, but it's actually an important one.
And depending on the language, the operands' order may actually change
the program's behavior!</p></li>
</ol></li>
</ol>
<h3 id="sequences-1">Sequences</h3>
<ol>
<li><p>Indexing</p>
<p>In Haskell, to index a list (consequently strings too) you use the
<code>!!</code> function – indexes start at 0:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>] <span class="op">!!</span> <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;hello&quot;</span> <span class="op">!!</span> <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Char</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>], [<span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>, <span class="dv">11</span>]] <span class="op">!!</span> <span class="dv">1</span> <span class="op">!!</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span></span></code></pre></div></li>
<li><p>Destructuring</p>
<p>Lists are defined as either being empty (<code>[]</code>), or having
a <em>head</em> and a <em>tail</em>, where the <em>head</em> is an
element of the list, and the <em>tail</em> is the rest of the list. So,
in order to destruct (i.e., separate) a list in its components, you use
the creatively named functions <code>head</code> and
<code>tail</code>:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]<span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> <span class="st">&quot;hello&quot;</span><span class="ot"> ::</span> <span class="dt">Char</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span> <span class="st">&quot;hello&quot;</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="co">-- [Char]</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> (<span class="fu">tail</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])<span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="fu">tail</span> (<span class="fu">tail</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])<span class="ot"> ::</span> [<span class="dt">Int</span>]</span></code></pre></div>
<p>Given that we can <em>destruct</em> a list into both its components,
we should also be able to <em>construct</em> a list given its components
– and that's what we'll learn now. You can construct a list with its
so-called <em>constructors</em>. As mentioned above, a list can be the
empty list, or a <em>head</em> and a <em>tail</em> put together. So we
need a way to create an empty list, and a way to create a list from its
<em>head</em> and its <em>tail</em>.</p>
<p>The empty list is easy, because it is itself – <code>[]</code> is the
empty list, there's no need to complicate.</p>
<p>And to put a <em>head</em> and a <em>tail</em> together to form a new
list you can use the <em>cons</em> operator <code>(:)</code>.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>[]<span class="ot"> ::</span> <span class="dt">String</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">:</span>) <span class="dv">1</span> []<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="op">:</span>[]<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="op">:</span>(<span class="dv">2</span><span class="op">:</span>(<span class="dv">3</span><span class="op">:</span>[]))<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="op">:</span><span class="dv">2</span><span class="op">:</span><span class="dv">3</span><span class="op">:</span>[]<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>[]<span class="op">:</span>[]<span class="ot"> ::</span> [[<span class="dt">String</span>]]</span></code></pre></div>
<p>What you saw above with <code>(:)</code> is an important Haskell
convention to keep in mind. A function (or operator) that's
defined/called as <code>(fun)</code> (notice the parentheses) is an
<em>infix</em> operator, i.e., it's placed in between the operands when
used; while usually, for example with <code>head</code> and
<code>tail</code>, functions are <em>prefix</em>, i.e., they're placed
before the operands when used. The most common examples of
<em>infix</em> operators are the arithmetic operators (<code>(+)</code>,
<code>(/)</code>, etc). To turn an <em>infix</em> operator into a
<em>prefix</em> operator, all you have to do is surround the operator
with parentheses. So, <code>(+) 1 2</code> is the same as
<code>1 + 2</code>.</p>
<p>There's also a convention to turn <em>prefix</em> operators into
<em>infix</em> operators, which is to surround the operator with
backticks (<code>`</code>) – we don't have an example yet, but it goes
like this: <code>op arg1 arg2</code> is equivalent to
<code>arg1 `op` arg2</code>. Later on we'll get to see examples of
this.</p></li>
<li><p>Concatenation</p>
<p>The operation that takes two sequences of the same type and "glues"
them together is called <em>concatenation</em>.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">0</span>, <span class="dv">1</span>] <span class="op">++</span> [<span class="dv">2</span>, <span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">++</span>) [<span class="dv">0</span>, <span class="dv">1</span>] [<span class="dv">2</span>, <span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;hello&quot;</span> <span class="op">++</span> <span class="st">&quot; &quot;</span> <span class="op">++</span> <span class="st">&quot;world&quot;</span><span class="ot"> ::</span> <span class="dt">String</span></span></code></pre></div></li>
<li><p><span class="todo TODO">TODO</span> Interpolation?</p></li>
</ol>
<h3 id="order-comparison-equality-etc">Order – comparison, equality,
etc</h3>
<p>Something else that's common in mathematics is comparing or equating
things. For example, we can say that <span
class="math inline">2 &lt; 3</span>, that <span
class="math inline">2 + 2 = 4</span>, that <span
class="math inline">3 ⋅ 3 &gt; 3</span>, that <span
class="math inline">1 + 1 ≠ 1</span>, etc. When programming, being able
to compare and equate things is also very useful. Table [-@tbl:cmpops]
has the correspondence between the comparison in mathematical notation
and Haskell.</p>
<table id="tbl:cmpops">
<caption>Comparison operators</caption>
<thead>
<tr class="header">
<th>Mathematics</th>
<th>Haskell</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">&lt;</span></td>
<td><code>&lt;</code></td>
</tr>
<tr class="even">
<td><span class="math inline">&gt;</span></td>
<td><code>&gt;</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">≤</span></td>
<td><code>&lt;=</code></td>
</tr>
<tr class="even">
<td><span class="math inline">≥</span></td>
<td><code>&gt;=</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">=</span></td>
<td><code>==</code></td>
</tr>
<tr class="even">
<td><span class="math inline">≠</span></td>
<td><code>/=</code></td>
</tr>
</tbody>
</table>
<p>The reason to use <code>==</code> instead of <code>=</code> for
equality will be clear next.</p>
<h2 id="pure-numerical-functions-sn---sm">(Pure) Numerical Functions –
S<sup>n</sup> -&gt; S<sup>m</sup></h2>
<p>Let's start now defining our own functions. A very high-level and
hand-wavy way to explain is: you translate <span
class="math inline"><em>f</em>(<em>x</em>) = <em>e</em><em>x</em><em>p</em><em>r</em></span>
into Haskell as <code>f x = expr</code>. So, for example, to define the
<em>identity</em> function, <span
class="math inline"><em>i</em><em>d</em><em>e</em><em>n</em><em>t</em><em>i</em><em>t</em><em>y</em>(<em>x</em>) = <em>x</em></span>,
in Haskell, you write <code>identity x = x</code>. For multivariable
functions, you just need to add the parentheses in Haskell: <span
class="math inline"><em>f</em>(<em>x</em>,<em>y</em>) = <em>x</em> ⋅ <em>y</em></span>
translates to <code>f (x, y) = x * y</code>; <span
class="math inline"><em>f</em>(<em>x</em>,<em>y</em>) = (<em>y</em>,<em>x</em>)</span>
translates to <code>f (x, y) = (y, x)</code>; <span
class="math inline"><em>f</em>(<em>x</em>) = (<em>x</em>,<em>x</em>)</span>
translates to <code>f x = (x, x)</code>; etc.</p>
<h3 id="doubles">Doubles</h3>
<p>Define a function in Haskell that given an <code>Int</code> doubles
it [@lst:int<sub>double</sub>], the equivalent of <span
class="math inline"><em>f</em>(<em>x</em>) = <em>x</em> ⋅ <em>x</em></span>.</p>
<p>How would you define a function that given a <code>Float</code>
doubles it [@lst:float<sub>double</sub>]?</p>
<h3 id="squares">Squares</h3>
<p>Define a function in Haskell that given an <code>Int</code> squares
it [@lst:int<sub>square</sub>].</p>
<p>How would you define a function that given a <code>Float</code>
squares it [@lst:float<sub>square</sub>]?</p>
<h3 id="etc">etc</h3>
<h3 id="function-composition">Function composition</h3>
<p>Like in mathematics (calculus), it's possible to compose functions to
define a new function. The notation is similar, and so are the
semantics: <span
class="math inline">(<em>f</em>∘<em>g</em>)(<em>x</em>)</span> is the
same as <span
class="math inline"><em>f</em>(<em>g</em>(<em>x</em>))</span>. And in
Haskell:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- What if we want Float?</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">double_square ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- double_square x = double (square x)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>double_square <span class="ot">=</span> double <span class="op">.</span> square</span></code></pre></div>
<p>As subtly implied at the beginning of this section, in the case of
multivariable functions, composition also <em>just works</em>, as long
as the types match.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>h x <span class="ot">=</span> (x, x <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>g (x, y) <span class="ot">=</span> (x <span class="op">*</span> <span class="dv">3</span>, y <span class="op">*</span> <span class="dv">2</span>, x <span class="op">+</span> y)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>f (x, y, z) <span class="ot">=</span> x <span class="op">*</span> y <span class="op">+</span> z</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>k <span class="ot">=</span> f <span class="op">.</span> g <span class="op">.</span> h</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Define k by expanding the definitions of f, g, and h;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- i.e., define k with a single expression.</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>k&#39; <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- What happens if you change this expression to another</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- type of number?</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>k <span class="dv">10</span><span class="ot"> ::</span> <span class="dt">Int</span></span></code></pre></div>
<h2 id="pure-logical-functions">(Pure) Logical Functions</h2>
<p>Before <span class="spurious-link"
target="(Pure) Predicates on Numbers"><em>(Pure) Predicates on
Numbers</em></span> for background.</p>
<p>This is going to be a packed section, with several important bits.
Let's start with <em>flow control</em>.</p>
<h3 id="flow-control">Flow Control</h3>
<p>It sometimes may happen that we need or want a function to do
different things depending on some condition. Imagine we're defining the
<em>absolute</em> function, i.e., the function that given a (signed)
number always returns a positive number, that is the input number
itself, or its symmetric:</p>
<p><span class="math display">$$
abs(x) =
\begin{cases}
-x &amp; \text{if}\ x &lt; 0 \\
x  &amp; \text{otherwise} \\
\end{cases}
$$</span></p>
<p>In Haskell, the most basic statement we have for this is the
<code>if then else</code>. We could translate the function above to
this:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">abs</span> x <span class="ot">=</span> <span class="kw">if</span> x <span class="op">&lt;</span> <span class="dv">0</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> <span class="op">-</span>x</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> x</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Note that the line breaks aren&#39;t necessary; this is also OK:</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="fu">abs</span> x <span class="ot">=</span> <span class="kw">if</span> x <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="op">-</span>x <span class="kw">else</span> x</span></code></pre></div>
<p>This is already enough to get everything needing flow control done.
However, with more clauses it quickly grows in size:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>f (x, y, z) <span class="ot">=</span> <span class="kw">if</span> cond1</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>              <span class="kw">then</span> expr1</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">else</span> <span class="kw">if</span> cond2</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">then</span> expr2</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">else</span> <span class="kw">if</span> cond3</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">then</span> expr3</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">else</span> <span class="kw">if</span> cond4</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>                             <span class="kw">then</span> expr4</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>                             <span class="kw">else</span> expr5</span></code></pre></div>
<p>This is hard to type, and when the expressions span several lines it
gets hard to read and understand the code. To remediate this problem, we
have <em>guards</em>:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>f (x, y, z) <span class="co">-- Notice that there&#39;s no equal sign here!</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> cond1 <span class="ot">=</span> expr1</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> cond2 <span class="ot">=</span> expr2</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> cond3 <span class="ot">=</span> expr3</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> cond4 <span class="ot">=</span> expr4</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> expr5</span></code></pre></div>
<p>The conditions are evaluated one by one, in the order defined; if a
condition evaluates to true, then the corresponding expression is
evaluated and its result is returned as the function's result; otherwise
the next condition is tried. This exactly like the
<code>if then else</code> expressions above. Because of that, you should
consider the order of the conditions when using guards.</p>
<p>The <code>otherwise</code> clause isn't necessary, but if all the
different conditions don't correspond to all the possible "states", that
is, if it's possible for all of the conditions to be false, then the
program will crash if there's no <code>otherwise</code> clause.</p>
<p>Next we'll learn about a major Haskell feature, available on many
functional programming languages, but not as much in imperative
languages.</p>
<h3 id="pattern-matching-and-function-clauses">Pattern Matching and
Function Clauses</h3>
<p><em>Pattern matching</em> allows us to <em>match</em> values
according to patterns. For example, if we were to define arithmetic
operators, we should probably add one or more clauses to take care of 0
or 1, because they're usually "special".</p>
<p><span class="math display">$$
mul(x, y) =
\begin{cases}
0 &amp; \text{if}\ x = 0 \\
0 &amp; \text{if}\ y = 0 \\
y &amp; \text{if}\ x = 1 \\
x &amp; \text{if}\ y = 1 \\
\text{The common case...} &amp; otherwise \\
\end{cases}
$$</span></p>
<p>We can already define an equivalent function in Haskell using either
<code>if then
else</code> or guards:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>mul (x, y)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> x <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> y <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> x <span class="op">==</span> <span class="dv">1</span> <span class="ot">=</span> y</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> y <span class="op">==</span> <span class="dv">1</span> <span class="ot">=</span> x</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- `undefined` can be used to &quot;make holes&quot; when we don&#39;t</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- know how to, or don&#39;t want to define some expression.</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>And you might be able to guess that <em>pattern matching</em>
(together with several function clauses) can be used to define this
function even more succinctly:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>mul (x, y) <span class="ot">=</span> <span class="kw">case</span> (x, y) <span class="kw">of</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, y) <span class="ot">-&gt;</span> <span class="dv">0</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    (x, <span class="dv">0</span>) <span class="ot">-&gt;</span> <span class="dv">0</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, y) <span class="ot">-&gt;</span> y</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    (x, <span class="dv">1</span>) <span class="ot">-&gt;</span> x</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    (x, y) <span class="ot">-&gt;</span> <span class="fu">undefined</span></span></code></pre></div>
<p>A function clause is analogous to a guard clause – each one will be
tried in order, and the first one to "work" is chosen. Each of the
clauses consists of a <em>pattern</em>, and when the function is called,
the arguments are matched with the pattern. If they do match, then the
corresponding expression is evaluated, and its result is returned as the
function's result. Otherwise, the next pattern is tried. Also similarly
to guards, if the arguments don't match any of the patterns, then an
error is thrown.</p>
<p>One last tip on pattern matching: if you don't care about a
particular value, you can give it the pattern <code>_</code>, which will
match <em>anything</em>, but won't be given a name. Thus, the first two
clauses of the <code>mul</code> function could be rewritten like
this:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>mul (x, y) <span class="ot">=</span> <span class="kw">case</span> (x, y) <span class="kw">of</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, _) <span class="ot">-&gt;</span> <span class="dv">0</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    (_, <span class="dv">0</span>) <span class="ot">-&gt;</span> <span class="dv">0</span></span></code></pre></div>
<p>Pattern matching isn't limited to numbers, however – you can pattern
match on values of any type. And that's what you'll practice next.</p>
<p>Just one more thing before we move forward. Another Haskell syntax we
can use is <em>function clauses</em>. The "full" definition of
<code>mul</code> above can be rewritten like this:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>mul (<span class="dv">0</span>, _) <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>mul (_, <span class="dv">0</span>) <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>mul (<span class="dv">1</span>, y) <span class="ot">=</span> y</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>mul (x, <span class="dv">1</span>) <span class="ot">=</span> x</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>mul (x, y) <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>There's usually no good reason to use one over the other, as they are
equivalent. This latter definition is more <em>idiomatic</em>, but if
you prefer using <code>case</code>, then <code>case</code> is the way to
go!</p>
<h3 id="not">NOT</h3>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myNot ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>myNot <span class="dt">True</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>myNot <span class="dt">False</span> <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<h3 id="and">AND</h3>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myAnd ::</span> (<span class="dt">Bool</span>, <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>myAnd (<span class="dt">True</span>, <span class="dt">True</span>) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>myAnd (_, _) <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h3 id="or">OR</h3>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myOr ::</span> (<span class="dt">Bool</span>, <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>myOr (<span class="dt">False</span>, <span class="dt">False</span>) <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>myOr (_, _) <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<h3 id="xor">XOR</h3>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myXor ::</span> (<span class="dt">Bool</span>, <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>myXor (<span class="dt">True</span>, <span class="dt">False</span>) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>myXor (<span class="dt">False</span>, <span class="dt">True</span>) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>myXor (_, _) <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h3 id="haskell-boolean-operators">Haskell Boolean Operators</h3>
<p>Haskell already has most of these operations defined. Here's the
table:</p>
<table>
<thead>
<tr class="header">
<th>Math</th>
<th>Haskell</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">∧</span></td>
<td><code>&amp;&amp;</code></td>
</tr>
<tr class="even">
<td><span class="math inline">∨</span></td>
<td><code>||</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">¬</span></td>
<td><code>not</code></td>
</tr>
</tbody>
</table>
<p>Define the following boolean function, first using the
<code>my*</code> functions defined above, and then using the standard
Haskell boolean operators:</p>
<p><span
class="math display"><em>h</em> : (<em>B</em><em>o</em><em>o</em><em>l</em>×<em>B</em><em>o</em><em>o</em><em>l</em>×<em>B</em><em>o</em><em>o</em><em>l</em>) → (<em>B</em><em>o</em><em>o</em><em>l</em>×<em>B</em><em>o</em><em>o</em><em>l</em>)</span>
<span
class="math display"><em>h</em>(<em>a</em>,<em>b</em>,<em>c</em>) = ((<em>a</em>∧<em>b</em>)⊕<em>c</em>,<em>a</em>∨<em>b</em>∨<em>c</em>)</span></p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">h ::</span> (<span class="dt">Bool</span>, <span class="dt">Bool</span>, <span class="dt">Bool</span>) <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, <span class="dt">Bool</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>h (a, b, c) <span class="ot">=</span> (myXor (myAnd (a, b)) c, myOr a (myOr b c))</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>h (a, b, c) <span class="ot">=</span> (myXor (a <span class="op">&amp;&amp;</span> b) c, a <span class="op">||</span> b <span class="op">||</span> c)</span></code></pre></div>
<h2 id="pure-predicates-on-numbers">(Pure) Predicates on Numbers</h2>
<h3 id="is-evenodd-in-terms-of-division">Is even/odd? – in terms of
division</h3>
<p>The functions <code>div</code>, <code>mod</code>, and
<code>divMod</code> may be useful.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- All of the following definitions are valid.</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="ot">isEven ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>isEven n <span class="ot">=</span> (a <span class="ot">`mod`</span> <span class="dv">2</span>) <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>isEven n <span class="ot">=</span> (a <span class="ot">`mod`</span> <span class="dv">2</span>) <span class="op">/=</span> <span class="dv">1</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>isEven n <span class="ot">=</span> <span class="kw">case</span> a <span class="ot">`mod`</span> <span class="dv">2</span> <span class="kw">of</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>isEven n <span class="ot">=</span> <span class="fu">not</span> isOdd n</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>isEven <span class="ot">=</span> <span class="fu">not</span> <span class="op">.</span> isOdd</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- All of the following definitions are valid.</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a><span class="ot">isOdd ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>isOdd n <span class="ot">=</span> (a <span class="ot">`mod`</span> <span class="dv">2</span>) <span class="op">==</span> <span class="dv">1</span></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>isOdd n <span class="ot">=</span> (a <span class="ot">`mod`</span> <span class="dv">2</span>) <span class="op">/=</span> <span class="dv">0</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>isOdd n <span class="ot">=</span> <span class="kw">case</span> a <span class="ot">`mod`</span> <span class="dv">2</span> <span class="kw">of</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>isOdd n <span class="ot">=</span> <span class="fu">not</span> isEven n</span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>isOdd <span class="ot">=</span> <span class="fu">not</span> <span class="op">.</span> isEven</span></code></pre></div>
<p>The only pair of definitions that wouldn't work is that of the
mutually recursive definitions, that is, the one where each function
calls the other. More details about recursive functions will come
next.</p>
<h3 id="is-multiple-in-terms-of-division">Is multiple? – in terms of
division</h3>
<p>The functions <code>div</code>, <code>mod</code>, and
<code>divMod</code> may be useful.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isMultiple ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>isMultiple a b <span class="ot">=</span> (a <span class="ot">`mod`</span> b) <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>isMultiple a b <span class="ot">=</span> <span class="kw">case</span> a <span class="ot">`mod`</span> b <span class="kw">of</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">True</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="dt">False</span></span></code></pre></div>
<h3 id="etc-1">etc</h3>
<h2 id="pure-predicates-on-chars">(Pure) Predicates on Chars?</h2>
<h3 id="is-digit">Is digit?</h3>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">isDigit</span> <span class="ch">&#39;0&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">isDigit</span> <span class="ch">&#39;1&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="fu">isDigit</span> <span class="ch">&#39;2&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="fu">isDigit</span> <span class="ch">&#39;3&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="fu">isDigit</span> <span class="ch">&#39;4&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="fu">isDigit</span> <span class="ch">&#39;5&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="fu">isDigit</span> <span class="ch">&#39;6&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="fu">isDigit</span> <span class="ch">&#39;7&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="fu">isDigit</span> <span class="ch">&#39;8&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="fu">isDigit</span> <span class="ch">&#39;9&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="fu">isDigit</span> _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h3 id="is-whitespace">Is whitespace?</h3>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>isWhitespace <span class="ch">&#39; &#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>isWhitespace <span class="ch">&#39;\t&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>isWhitespace <span class="ch">&#39;\v&#39;</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>isWhitespace _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h3 id="is-symbol">Is symbol?</h3>
<h3 id="is-alpha">Is alpha?</h3>
<h3 id="etc-2">etc</h3>
<h2 id="pure-recursive-functions-on-numbers">(Pure) Recursive Functions
on Numbers</h2>
<p>In short, recursive functions are functions that, directly or
indirectly, call themselves. A popular one is that of the Fibonacci
number:</p>
<p><span
class="math display"><em>f</em><em>i</em><em>b</em> : ℕ<sub>𝟘</sub> → ℕ</span>
<span class="math display">$$
fib(n) =
\begin{cases}
1 &amp; \text{if}\ n &lt; 2 \\
fib(n-1) + fib(n-2) &amp; \text{otherwise} \\
\end{cases}
$$</span></p>
<h3
id="fibonacci-the-mathematical-definition-recursive-process">Fibonacci –
the mathematical definition (recursive process)</h3>
<p>The definition above translates to:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>fib n</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> n <span class="op">&lt;</span> <span class="dv">2</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> fib (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib (n<span class="op">-</span><span class="dv">2</span>)</span></code></pre></div>
<h3 id="is-evenodd">Is even/odd?</h3>
<p>Here we're going to define <code>isEven</code> and <code>isOdd</code>
in a mutually recursive manner, but neither will use the
<code>mod</code> function. Instead, we'll say that a number <span
class="math inline"><em>n</em></span> is even if it 0, or if <span
class="math inline"><em>n</em> − 1</span> is odd. Likewise, we'll say
that a number <span class="math inline"><em>n</em></span> is odd if it
is not 0, or if <span class="math inline"><em>n</em> − 1</span> is
even.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isEven ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>isEven <span class="dv">0</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>isEven n <span class="ot">=</span> isOdd (n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="ot">isOdd ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>isOdd <span class="dv">0</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>isOdd n <span class="ot">=</span> isEven (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<h3 id="is-multiple">Is multiple?</h3>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">isMultiple ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>isMultiple a b</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">==</span> b <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">&gt;</span> b <span class="ot">=</span> isMultiple (a <span class="op">-</span> b) b</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">&lt;</span> b <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h3 id="sum-product-recursive-process">Sum, product, … – recursive
process</h3>
<p>Given two numbers <span class="math inline"><em>a</em></span> and
<span class="math inline"><em>b</em></span> such that <span
class="math inline"><em>a</em> &lt; <em>b</em></span>, we'll define the
following expressions: <span class="math inline">$\sum_{i=a}^b i$</span>
and <span class="math inline">$\prod_{i=a}^b i$</span>.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- What happens if a &gt; b?</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> a b</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">==</span> b <span class="ot">=</span> a</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">&lt;</span> b <span class="ot">=</span> a <span class="op">+</span> <span class="fu">sum</span> (a <span class="op">+</span> <span class="dv">1</span>) b</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- What happens if a &gt; b?</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>prod a b</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">==</span> b <span class="ot">=</span> a</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">&lt;</span> b <span class="ot">=</span> a <span class="op">*</span> prod (a <span class="op">+</span> <span class="dv">1</span>) b</span></code></pre></div>
<h3 id="sum-product-iterative-process">Sum, product, … – iterative
process</h3>
<p>Because of how the computers work, the definitions of
<code>sum</code> and <code>prod</code> above are very inefficient, and
may even not work for a large enough <span
class="math inline"><em>b</em> − <em>a</em></span>. That is because the
definitions above evolve into a <em>recursive process</em>; while
computers are <em>iterative</em> machines. To explain it better, let's
look at an example <code>sum</code> call, and manually evaluate it.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> <span class="dv">0</span> <span class="dv">4</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">+</span> <span class="fu">sum</span> <span class="dv">1</span> <span class="dv">4</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">+</span> (<span class="dv">1</span> <span class="op">+</span> <span class="fu">sum</span> <span class="dv">2</span> <span class="dv">4</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">+</span> (<span class="dv">1</span> <span class="op">+</span> (<span class="dv">2</span> <span class="op">+</span> <span class="fu">sum</span> <span class="dv">3</span> <span class="dv">4</span>))</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">+</span> (<span class="dv">1</span> <span class="op">+</span> (<span class="dv">2</span> <span class="op">+</span> (<span class="dv">3</span> <span class="op">+</span> <span class="fu">sum</span> <span class="dv">4</span> <span class="dv">4</span>)))</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">+</span> (<span class="dv">1</span> <span class="op">+</span> (<span class="dv">2</span> <span class="op">+</span> (<span class="dv">3</span> <span class="op">+</span> <span class="dv">4</span>)))</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">+</span> (<span class="dv">1</span> <span class="op">+</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">7</span>))</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">+</span> (<span class="dv">1</span> <span class="op">+</span> <span class="dv">9</span>)</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">+</span> <span class="dv">10</span></span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span></code></pre></div>
<p>It's possible to do better, however. Let's look at the iterative
definition, and then see the difference between the two by also manually
evaluating it.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> a b <span class="ot">=</span> sumAux <span class="dv">0</span> a b</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>sumAux ret a b</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">==</span> b <span class="ot">=</span> ret <span class="op">+</span> a</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">&lt;</span> b <span class="ot">=</span> sumAux (ret <span class="op">+</span> a) (a <span class="op">+</span> <span class="dv">1</span>) b</span></code></pre></div>
<p>Here's the manual evaluation of <code>sum 0 4</code>, according to
this new definition:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> <span class="dv">0</span> <span class="dv">4</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>sumAux <span class="dv">0</span> <span class="dv">0</span> <span class="dv">4</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>sumAux (<span class="dv">0</span> <span class="op">+</span> <span class="dv">0</span>) <span class="dv">1</span> <span class="dv">4</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>sumAux <span class="dv">0</span> <span class="dv">1</span> <span class="dv">4</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>sumAux (<span class="dv">0</span> <span class="op">+</span> <span class="dv">1</span>) <span class="dv">2</span> <span class="dv">4</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>sumAux <span class="dv">1</span> <span class="dv">2</span> <span class="dv">4</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>sumAux (<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>) <span class="dv">3</span> <span class="dv">4</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>sumAux <span class="dv">3</span> <span class="dv">3</span> <span class="dv">4</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>sumAux (<span class="dv">3</span> <span class="op">+</span> <span class="dv">3</span>) <span class="dv">4</span> <span class="dv">4</span></span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb34-19"><a href="#cb34-19" aria-hidden="true" tabindex="-1"></a>sumAux <span class="dv">6</span> <span class="dv">4</span> <span class="dv">4</span></span>
<span id="cb34-20"><a href="#cb34-20" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb34-21"><a href="#cb34-21" aria-hidden="true" tabindex="-1"></a><span class="dv">6</span> <span class="op">+</span> <span class="dv">4</span></span>
<span id="cb34-22"><a href="#cb34-22" aria-hidden="true" tabindex="-1"></a><span class="op">==</span></span>
<span id="cb34-23"><a href="#cb34-23" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span></span></code></pre></div>
<p>Notice that this function results in roughly the same number of
steps, but it doesn't grow "to the right", in a triangle, as with the
other definition. That is the big difference. If <span
class="math inline"><em>b</em> − <em>a</em> = <em>n</em></span>, then
the first definition would grow into a triangle of height <span
class="math inline"><em>n</em> + 1</span>, that is, it would evolve
eventually into a bunch of "pending" operations. With the second
definition, the number of "pending" operations can be considered
constant.</p>
<p>This new definition has a couple more steps, but that can be
improved, for example like this:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> a b</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">==</span> b <span class="ot">=</span> a</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">&lt;</span> b <span class="ot">=</span> sumAux a (a <span class="op">+</span> <span class="dv">1</span>) b</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="ot">sumAux ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>sumAux ret a b</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">==</span> b <span class="ot">=</span> ret <span class="op">+</span> a</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> a <span class="op">&lt;</span> b <span class="ot">=</span> sumAux (ret <span class="op">+</span> a) (a <span class="op">+</span> <span class="dv">1</span>) b</span></code></pre></div>
<p>Exercise: show that the two definitions are equivalent.</p>
<h3 id="fibonacci-iterative-process">Fibonacci – iterative process</h3>
<p>A similar iterative "conversion" can be applied to the Fibonacci
function. It isn't as obvious, but here's the definition:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>fib n <span class="ot">=</span> fibAux <span class="dv">1</span> <span class="dv">1</span> n</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- n1 corresponds to fib(n-1); and n2 correspends to fib(n-2)</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>fibAux n2 _ <span class="dv">0</span> <span class="ot">=</span> n2</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>fibAux n2 n1 s <span class="ot">=</span> fibAux n1 (n1 <span class="op">+</span> n2) (s <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<p>To try and explain by visualizing it, let's make a diagram. The
parentheses surround <code>n2</code> and <code>n1</code> (i.e., <span
class="math inline"><em>f</em><em>i</em><em>b</em>(<em>n</em>−2)</span>
and <span
class="math inline"><em>f</em><em>i</em><em>b</em>(<em>n</em>−1)</span>).</p>
<pre><code>fib(n=2) = 2
(1 1) 2 3 5 8 13

fib(n=3) = 3
1 (1 2) 3 5 8 13

fib(n=4) = 5
1 1 (2 3) 5 8 13

fib(n=5) = 8
1 1 2 (3 5) 8 13

fib(n=6) = 13
1 1 2 3 (5 8) 13
</code></pre>
<p>Exercise: manually evaluate <span
class="math inline"><em>f</em><em>i</em><em>b</em>(<em>n</em>)</span>,
according to the first mathematical definition and this new definition,
for a small <span class="math inline"><em>n</em></span> (<span
class="math inline"><em>n</em> &lt; 5</span>).</p>
<h3 id="etc-3">etc</h3>
<h2 id="pure-functions-on-sequences">(Pure) Functions on Sequences</h2>
<h3 id="is-empty">Is empty?</h3>
<div class="sourceCode" id="cb38"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">empty ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>empty [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>empty _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h3 id="has-member">Has member?</h3>
<div class="sourceCode" id="cb39"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">member ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>member _ [] <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>member x (y<span class="op">:</span>ys) <span class="ot">=</span> (x <span class="op">==</span> y) <span class="op">||</span> member x ys</span></code></pre></div>
<h3 id="length-recursive-and-iterative-processes">Length – recursive and
iterative processes</h3>
<div class="sourceCode" id="cb40"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span> (_<span class="op">:</span>xs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">length</span> xs</span></code></pre></div>
<p>This definition evolves into a recursive process, as we've seen
before, but it's possible to turn it into one that evolves into an
iterative process.</p>
<h3 id="reverse-recursive-and-iterative-processes">Reverse – recursive
and iterative processes</h3>
<div class="sourceCode" id="cb41"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> [] <span class="ot">=</span> []</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> (h<span class="op">:</span>t) <span class="ot">=</span> <span class="fu">reverse</span> t <span class="op">++</span> [h]</span></code></pre></div>
<p>This definition too, evolves into a recursive process, but there's a
better one evolving into an iterative process.</p>
<h3 id="etc-4">etc</h3>
<h2 id="pure-functions-over-sequences-explicit-recursion">(Pure)
Functions over Sequences (Explicit Recursion)</h2>
<p>Compare different definitions with recursive and iterative
processes.</p>
<h3 id="double-add-1">Double, add 1, …</h3>
<div class="sourceCode" id="cb42"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>double [] <span class="ot">=</span> []</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>double (h<span class="op">:</span>t) <span class="ot">=</span> (<span class="dv">2</span> <span class="op">*</span> h)<span class="op">:</span>(double t)</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>add1 [] <span class="ot">=</span> []</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>add1 (h<span class="op">:</span>t) <span class="ot">=</span> (h <span class="op">+</span> <span class="dv">1</span>)<span class="op">:</span>(add1 t)</span></code></pre></div>
<p>Notice that the two functions are essentially the same:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>func [] <span class="ot">=</span> []</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>func (h<span class="op">:</span>t) <span class="ot">=</span> (f h)<span class="op">:</span>(func t) <span class="co">-- for some given f</span></span></code></pre></div>
<p>For <code>double</code>, <code>f</code> would be <code>(*2)</code>;
and for <code>add1</code>, <code>(+1)</code>.</p>
<h3 id="sum-product"><code>sum</code>, <code>product</code>, …</h3>
<div class="sourceCode" id="cb44"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span><span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> [] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> (h<span class="op">:</span>t) <span class="ot">=</span> h <span class="op">+</span> <span class="fu">sum</span> t</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="fu">product</span><span class="ot"> ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="fu">product</span> [] <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="fu">product</span> (h<span class="op">:</span>t) <span class="ot">=</span> h <span class="op">*</span> <span class="fu">product</span> t</span></code></pre></div>
<p>Notice that here too, the two functions are essentially the same:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>func [] <span class="ot">=</span> ret <span class="co">-- for some given ret</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>func (h<span class="op">:</span>t) <span class="ot">=</span> h <span class="ot">`f`</span> func t <span class="co">-- for some given f</span></span></code></pre></div>
<p>For <code>sum</code>, <code>ret</code> would be 0, and <code>f</code>
would be <code>(+)</code>; and for <code>product</code>,
<code>ret</code> would be 1, and <code>f</code> would be
<code>(*)</code>.</p>
<h2 id="pure-functions-over-sequences-higher-order-functions">(Pure)
Functions over Sequences (Higher-order Functions)</h2>
<p>We saw in the previous chapter that some computations we want to
compute are very similar. In this chapter we'll see that they can indeed
be abstracted, that is, be made more general.</p>
<h3 id="map-double-add-1-triple"><code>map</code> – double, add 1,
triple, …</h3>
<div class="sourceCode" id="cb46"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> _ [] <span class="ot">=</span> []</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (h<span class="op">:</span>t) <span class="ot">=</span> (f h)<span class="op">:</span>(<span class="fu">map</span> f t)</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>double <span class="ot">=</span> <span class="fu">map</span> (<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>add1 <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>triple <span class="ot">=</span> <span class="fu">map</span> (<span class="op">*</span><span class="dv">3</span>)</span></code></pre></div>
<h3 id="fold-length-reverse-has-member"><code>fold</code> – length,
reverse, has member?, …</h3>
<h3 id="sum-product-1"><code>sum</code>, <code>product</code></h3>
<div class="sourceCode" id="cb47"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> _ ret [] <span class="ot">=</span> ret</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f ret (h<span class="op">:</span>t) <span class="ot">=</span> f h (<span class="fu">foldr</span> ret f t)</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">+</span>) <span class="dv">0</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="fu">product</span> <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">*</span>) <span class="dv">1</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span><span class="ot"> ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> _ ret [] <span class="ot">=</span> ret</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f ret (h<span class="op">:</span>t) <span class="ot">=</span> <span class="fu">foldl</span> f (f ret h) t</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> <span class="ot">=</span> <span class="fu">foldl</span> (<span class="op">+</span>) <span class="dv">0</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a><span class="fu">product</span> <span class="ot">=</span> <span class="fu">foldl</span> (<span class="op">*</span>) <span class="dv">1</span></span></code></pre></div>
<h3 id="map-in-terms-of-fold"><code>map</code> in terms of
<code>fold</code></h3>
<p>On top of these, <code>map</code> can also be written as a
<code>fold?</code>.</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f <span class="ot">=</span> <span class="fu">foldr</span> (\x ret <span class="ot">-&gt;</span> (f x) <span class="op">:</span> ret) []</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f <span class="ot">=</span> <span class="fu">foldl</span> (\ret x <span class="ot">-&gt;</span> (f x) <span class="op">:</span> ret) []</span></code></pre></div>
<p>How do these two definitions differ from each other? How do the
definitions for <code>sum</code> and <code>product</code> using
<code>foldr</code> and <code>foldl</code> differ from each other? How
does <code>foldr</code> differ from <code>foldl</code>? Is one better
than the other? Should one be preferred over the other?</p>
<h1 id="exercise-solutions">Exercise Solutions</h1>
<div class="captioned-content">
<div class="caption">
Doubles a given integer.
</div>
<div class="sourceCode" id="cb49"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">double ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>double x <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> x</span></code></pre></div>
</div>
<div class="captioned-content">
<div class="caption">
Doubles a given float.
</div>
<div class="sourceCode" id="cb50"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">double ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>double x <span class="ot">=</span> <span class="dv">2</span> <span class="op">*</span> x</span></code></pre></div>
</div>
<div class="captioned-content">
<div class="caption">
Squares a given integer.
</div>
<div class="sourceCode" id="cb51"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>square x <span class="ot">=</span> x <span class="op">*</span> x</span></code></pre></div>
</div>
<div class="captioned-content">
<div class="caption">
Squares a given float.
</div>
<div class="sourceCode" id="cb52"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>square x <span class="ot">=</span> x <span class="op">*</span> x</span></code></pre></div>
</div>
