<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html lang="en" xml:lang="en"><head><meta charset="utf-8"></meta></head><body><h1>ChibiAkumas, &quot;RISC-V Assembly Programming&quot;</h1><p>siiky<br></br>2023/05/05<br></br>2023/05/05<br></br>2023/05/12<br></br>video,programming</p><ul><li><a href="https://odysee.com/@ChibiAkumas:7/Learn-Risc-V-Assembly-Programming---Lesson1-_-For-absolute-beginners!:c">https://odysee.com/@ChibiAkumas:7/Learn-Risc-V-Assembly-Programming---Lesson1-_-For-absolute-beginners!:c</a></li><li><a href="https://odysee.com/@ChibiAkumas:7/RISC-V-Lesson-2---The-stack-and-conditions:a">https://odysee.com/@ChibiAkumas:7/RISC-V-Lesson-2---The-stack-and-conditions:a</a></li><li><a href="https://odysee.com/@ChibiAkumas:7/Risc-V-Assembly-Lesson-3---Bit-ops-and-more-maths!:9">https://odysee.com/@ChibiAkumas:7/Risc-V-Assembly-Lesson-3---Bit-ops-and-more-maths!:9</a></li><li><a href="https://invidious.snopyta.org/watch?v=bEUMLh2lasE">https://invidious.snopyta.org/watch?v=bEUMLh2lasE</a></li><li><a href="https://invidious.snopyta.org/watch?v=rvhDyJVuAzk">https://invidious.snopyta.org/watch?v=rvhDyJVuAzk</a></li><li><a href="https://invidious.snopyta.org/watch?v=mV8HUKxLRxI">https://invidious.snopyta.org/watch?v=mV8HUKxLRxI</a></li></ul><p>Set of videos on RISC-V assembly programming.</p><ul><li><a href="https://www.chibialiens.com/riscv">https://www.chibialiens.com/riscv</a></li><li><a href="https://www.chibialiens.com/riscv/RiscVCheatsheet.pdf">https://www.chibialiens.com/riscv/RiscVCheatsheet.pdf</a></li></ul><h2>Instructions</h2><ul><li>addi dst, src, imm -- add immediate</li><li>add dst, src1, src2 -- add</li><li>la reg, addr -- load address</li><li>lw dst, src -- load word (32bit in a 32bit CPU, 64bit in a 64bit CPU, ...)</li><li>lhu dst, src -- load half word unsigned (16bit in a 32bit CPU, 32bit in a 64bit CPU, ...); top half is filled with 0s</li><li>lh dst, src -- load half word (16bit in a 32bit CPU, 32bit in a 64bit CPU, ...); top half is filled with bit 15/31 (in a 32/64bit CPU, resp.), which keeps the sign</li><li>lbu dst, src -- load byte unsigned; top half is filled with 0s</li><li>lb dst, src -- load byte; top half is filled with bit 7, which keeps the sign</li><li>sw src, dst -- store word</li><li>sh src, dst -- store half word</li><li>sb src, dst -- store byte</li><li>j lbl -- jump to label</li><li>jr reg -- jump to address stored in reg</li><li>jal lbl -- jump and link to label</li><li>jalr reg -- jump and link to address stored in reg</li><li>ret -- return from procedure</li><li>mv dst, src -- move</li><li>li reg, imm -- load immediate</li><li>beq reg1, reg2, lbl -- branch equal</li><li>bne reg1, reg2, lbl -- branch not equal</li><li>bltu reg1, reg2, lbl -- branch lesser-than unsigned</li><li>bgtu reg1, reg2, lbl -- branch greater-than unsigned</li><li>bleu reg1, reg2, lbl -- branch lesser-or-equal unsigned</li><li>bgeu reg1, reg2, lbl -- branch greater-or-equal unsigned</li><li>blt reg1, reg2, lbl -- branch lesser-than signed</li><li>bgt reg1, reg2, lbl -- branch greater-than signed</li><li>ble reg1, reg2, lbl -- branch lesser-or-equal signed</li><li>bge reg1, reg2, lbl -- branch greater-or-equal signed</li><li>beqz reg, lbl -- branch equal zero -- equivalent to beq reg, zero, lbl</li><li>bnez reg, lbl -- branch not equal zero -- equivalent to bne reg, zero, lbl</li><li>lui reg, imm -- load upper immediate (&quot;upper&quot; part is the top 20 bits)</li><li>not dst, src -- binary not, flips all bits</li><li>neg dst, src -- negate number, i.e., compute 2&#39;s complement</li><li>sll dst, src1, src2 -- shift left logical (ignoring sign) -- dst = src1 &lt;&lt; src2</li><li>srl dst, src1, src2 -- shift right logical (ignoring sign) -- dst = src1 &gt;&gt; src2</li><li>sla dst, src1, src2 -- shift left arithmetic (considering sign) -- dst = src1 &lt;&lt; src2</li><li>sra dst, src1, src2 -- shift right arithmetic (considering sign) -- dst = src1 &gt;&gt; src2</li><li>slli dst, src, imm -- shift left logical immediate (ignoring sign) -- dst = src &lt;&lt; imm</li><li>srli dst, src, imm -- shift right logical immediate (ignoring sign) -- dst = src &gt;&gt; imm</li><li>slai dst, src, imm -- shift left arithmetic immediate (considering sign) -- dst = src &lt;&lt; imm</li><li>srai dst, src, imm -- shift right arithmetic immediate (considering sign) -- dst = src &gt;&gt; imm</li><li>sltu dst, src, imm -- set lesser-than unsigned -- dst = src1 &lt; src2</li><li>sgt dst, src1, src2 -- set greater-than -- dst = src1 &gt; src2</li><li>sgei dst, src, imm -- set greater-than immediate -- dst = src &gt;= imm</li></ul><h2>Addressing</h2><ul><li>Immediate -- no special characters or anything: 123, 0, -42, ...</li><li>Indirect register -- the register name is surrounded by parens, optionally with an immediate byte offset value to the left: (a2), (a3), 32(a1), ...</li></ul><h2>Stack</h2><p>The RISC-V has no instructions to manipulate the stack specifically, one has to load/store and update the sp in two instructions.</p><h2>Note on load immediate</h2><p>If I&#39;m understanding this right, because of how instructions are encoded (fixed size? as opposed to variable size as in x86), a &quot;load immediate&quot; instruction can&#39;t load a full word in a single &quot;command&quot;(?), because each instruction, including its arguments, is encoded as a word (again, if I&#39;m understanding this right).</p><p>Because of that, the li instruction must be decomposed in two (generally I suppose; probably by the assembler). For example (assuming rv32):</p><pre>li a0, 0xABCD0123
</pre><p>Must be something like:</p><pre>lhi a0, 0x123 # this doesn&#39;t actually exist
lui a0, 0xABCD0
</pre></body></html>