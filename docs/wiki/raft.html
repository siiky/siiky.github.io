<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html lang="en" xml:lang="en"><head><meta charset="utf-8"></meta></head><body><h1>Raft</h1><p>siiky<br></br>2021/10/23<br></br>2023/03/13<br></br>2023/03/13<br></br>p2p,distributed,algorithms</p><ul><li><a href="https://raft.github.io">https://raft.github.io</a></li></ul><p>Distributed consensus algorithm, first described in the following paper:</p><ul><li><a href="wp.diego_ongaro.raft.html">wp.diego_ongaro.raft.html</a></li></ul><h2>Simple high-level view</h2><p>From &quot;The Secret Lives of Data&quot;, an interactive presentation of the Raft algorithm.</p><ul><li><a href="https://thesecretlivesofdata.com">https://thesecretlivesofdata.com</a></li></ul><p>A node of a cluster using the Raft algorithm can be in one of three states:</p><ul><li>Follower</li><li>Candidate</li><li>Leader</li></ul><h3>Leader Election</h3><p>All nodes start initially in the follower state.</p><p>Followers can become candidates if they don&#39;t hear of a leader.</p><p>A candidate becomes a leader through the process of leader election. The candidate requests other nodes to vote, and if the majority of nodes vote for, then it becomes the leader.</p><h3>Log Replication</h3><p>Changes to the system go through the process of log replication, described next.</p><p>All changes to the system go through the leader, and each change is added as an (uncommitted) entry to the leader&#39;s log.</p><p>Uncommitted entries in a node&#39;s log don&#39;t update its value.</p><p>To commit an (uncommitted) entry, the leader replicates it to the followers, and the leader waits until a majority of nodes have the entry as well. With this, the entry becomes committed, the value is updated according to it, and the leader notifies the followers that this entry is now committed.</p><h2>Election Term</h2><p>An election term is the &quot;time&quot; between each leader election.</p><p>There are two timeouts (settings?) that control elections, as the systems evolves through time: election timeout and heartbeat timeout.</p><p>The election timeout is the ammount of time a follower waits until it decides to become a candidate. Random between 150ms and 300ms.</p><p>When a node becomes a candidate it starts a new election term, votes for itself, and sends request vote messages to other nodes.</p><p>If a node receiving a request vote message hasn&#39;t voted yet in this term, then it votes for the candidate that sent the request, and resets its election timeout.</p><p>As said before, once the candidate has the majority of votes from the other nodes, it becomes the leader. This requirement guarantees that only one leader can be elected per term.</p><p>Once leader, a node begins sending append entries messages to its followers, in intervals set by the heartbeat timeout, and followers reply to each. This back and forth goes on until a follower stops receiving heartbeats and becomes a candidate.</p><p>In case two nodes become candidates nearly at the same time, a split voting occurs. Voting goes as described before and if one of the nodes has the mojority of votes, it becomes the leader; if instead there&#39;s a tie, no leader is elected, and all nodes wait for a new term to start.</p><p>When voting, a node not only replies to the candidate node it&#39;s voting for, but also shares its vote will all other nodes. This is crucial to the voting consensus.</p><h2>Log Replication</h2><p>To replicate changes to the system between all nodes, the append entries messages are used to share log entries.</p><p>A client sends a change to the leader, which appends this change as an entry to its log. And on the next heartbeat (append entries message), it sends also the change to its followers.</p><p>Once a majority of nodes acknowledges this change, the leader commits it in its log, and a reply is given to the client.</p><h2>In Case of Network Partition</h2><p>If a network partition occurs, the group with the leader will continue to function as normal; the group with no leader will reach a new election term, and a new leader will be elected.</p><p>If different clients send changes to different leaders, the group with the majority will commit the changes, but the other group will not. Once both groups regain connection, the leader with the highest election term &quot;wins&quot; and becomes leader of the whole cluster.</p><p>It&#39;s possible that in a network partition that splits the cluster in two groups, the leader ending up in the minority group, both groups receive client requests, and that the minority group gets more requests, gets more work done. However, once the partition is solved, the majority wins. Is this the right thing to do? Is it possible to do better?</p><h2>Questions</h2><h3>Why does the election term win in the case of a network partition?</h3><p>Why not majority of nodes?</p><p>I may have misunderstood this detail a couple of years ago. Professor will think/read more about it and try to answer definitively later.</p><h3>Some of the details seem to require that all nodes know of all other nodes</h3><p>Is this true? Not quite.</p><p>From an implementation&#39;s POV, all that&#39;s necessary is a way to contact all members of the group -- this could be the nodes&#39; IPs, some kind of multicast, or whatever. And what is really necessary from the algorithm&#39;s POV is only the number of nodes in the group, to know when a majority is reached.</p><h3>If only leaders reply to clients, and followers redirect requests to leaders, what do candidates do to clients&#39; requests?</h3><h3>Is the election timeout random on each reset?</h3></body></html>