<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html lang="en" xml:lang="en"><head><meta charset="utf-8"></meta></head><body><h1>&quot;Assembly Language Programming with ARM â€“ Full Tutorial for Beginners&quot;</h1><p>siiky<br></br>2023/05/04<br></br>2023/05/04<br></br>2023/05/04<br></br>video,course,programming</p><ul><li><a href="https://www.freecodecamp.org/news/learn-assembly-language-programming-with-arm/">https://www.freecodecamp.org/news/learn-assembly-language-programming-with-arm/</a></li><li><a href="https://invidious.snopyta.org/watch?v=gfmRrPjnEw4">https://invidious.snopyta.org/watch?v=gfmRrPjnEw4</a></li></ul><p>Short-ish freecodecamp video about ARM assembly.</p><h2>Notes</h2><p>Registers R0 through R12, SP (Stack Pointer), LR (Link Register?), PC (Program Counter). R7 is used to specify syscalls. CPSR contains arithmetic flags (Negative, Carry, Zero, &amp;c).</p><p>The different types of addressing:</p><ul><li>Immediate -- values are prefixed with # -- e.g. #42 for the decimal number 42, or #0xAB for the hexadecimal number AB.</li><li>Register direct addressing -- the name of the register by itself.</li><li>Direct -- labels are prefixed with = -- e.g. =somedata for the address of the label somedata.</li><li>Register indirect addressing -- the register name is surrounded by square brackets -- e.g. [R3]; optionally an offset may be specified.</li><li>Pre-increment -- like &quot;register indirect addressing&quot;, but additionally everything is suffixed with ! -- e.g. [R2,#4]!</li><li>Post-increment -- like &quot;register indirect addressing&quot;, but the offset is specified outside -- e.g. [R2],#4</li></ul><p>Common instructions:</p><ul><li>MOV DST, SRC -- move, duh</li><li>SWI X -- Software Interrupt -- what&#39;s X?</li><li>LDR REG, =ADDR -- load an address into a register</li><li>ADD DST, SRC1, SRC2 -- DST = SRC1 + SRC2</li><li>SUB DST, SRC1, SRC2 -- DST = SRC1 - SRC2</li><li>MUL DST, SRC1, SRC2 -- DST = SRC1 * SRC2</li><li>ADDS DST, SRC1, SRC2 -- like the operations above, but also set the right flags in the CPSR register</li><li>SUBS DST, SRC1, SRC2 -- like the operations above, but also set the right flags in the CPSR register</li><li>MULS DST, SRC1, SRC2 -- like the operations above, but also set the right flags in the CPSR register</li><li>ADC DSR, SRC1, SRC2 -- like ADD, but also adds the carry from CPSR</li><li>AND DST, SRC1, SRC2 -- binary AND, e.g. 0xFF &amp; 0x16 = 0x16</li><li>ORR DST, SRC1, SRC2 -- binary OR, e.g. 0xFF | 0x16 = 0xFF</li><li>EOR DST, SRC1, SRC2 -- binary XOR, e.g. 0xFF ^ 0x16 = 0xE9</li><li>MVN DST, SRC -- binary NOT, e.g. ~0xFF = 0xFFFFFF00 (negates the whole register, of course)</li><li>LSL REG, #IM -- logical left shift</li><li>LSR REG, #IM -- logical right shift</li><li>ROR REG, #IM -- right rotation</li><li>MOV DST, SRC, LSL #IM -- save in DST the result of shifting SRC left #IM</li><li>MOV DST, SRC, LSR #IM -- save in DST the result of shifting SRC right #IM</li><li>CMP REG1, REG2 -- compare the values of two registers by computing REG1-REG2</li><li>BGT LBL -- jump if greater-than (Branch Greater-Than)</li><li>BGE LBL -- jump if greater-or-equal (Branch Greater-or-Equal)</li><li>BLT LBL -- jump if lesser-than (Branch Lesser-Than)</li><li>BLE LBL -- jump if greater-or-equal (Branch Greater-or-Equal)</li><li>BEQ LBL -- jump if equal (Branch EQual)</li><li>BNE LBL -- jump if not equal (Branch Not Equal)</li><li>BAL LBL -- jump (Branch ALways)</li><li>ADDLT DST, SRC -- compute DST += SRC if the last comparison was lesser-than</li><li>MOVEQ DST, SRC -- DST = SRC if the last comparison was equal</li><li>BL LBL -- Branch Linked (&quot;call&quot;?)</li><li>BX REG -- Branch eXit? Usually called on LR</li><li>B LBL -- Branch? What&#39;s the difference with BAL?</li><li>PUSH {REG, ...} -- push values onto the stack; e.g. PUSH {R0, R2, R3}</li><li>POP {REG, ...} -- pop values off the stack; e.g. POP {R0, R2, R3}</li><li>STR SRC, DST -- store the value of SRC in DST</li></ul><pre>.global _start
_start:
	MOV R0,=somedata // Save in R0 the address of somedata

	LDR R1,[R0] // Save in R1 the value stored at the address that&#39;s stored in R0 -- equivalent to R1 = *R0

	LDR R2,[R0,#4] // Save in R2 the value stored at the address that&#39;s stored in R0, plus 4 bytes -- equivalent to R2 = *(R0+4)

	LDR R3,[R0,#4]! // Save in R2 the value stored at the address that&#39;s stored in R0, plus 4 bytes -- equivalent to R3 = *(++R0) (assume ++ increments 4 bytes)

	LDR R4,[R0],#4 // Save in R2 the value stored at the address that&#39;s stored in R0, plus 4 bytes -- equivalent to R4 = *(R0++) (assume ++ increments 4 bytes)

	MOV R7,#1 // 1 is the exit syscall code
	SWI 0

.data
somedata:
	.word 4,2
</pre><h3>Procedure calls</h3><pre>.global _start
_start:
	MOV R0, #1
	MOV R1, #3
	PUSH {R0, R1}
	BL get_value
	POP {R0, R1}
	B end

get_value:
	MOV R0, #5
	MOV R1, #7
	ADD R2, R0, R1
	BX LR

end:
</pre><h2>First program</h2><p>Actually wrote it before the video went into loops, with this exact example. The code is very different though.</p><pre>.global _start
_start:
	LDR R0, =list // array ptr
	MOV R1, #1 // current index
	
	LDR R2, [R0] // sum
	
loop:
	LDR R3, [R0, #4]! // get value at current index and move array ptr forward
	ADD R2, R2, R3 // add current value to sum
	
	ADD R1, R1, #1 // increment index

	CMP R1, #10
	BLT loop // index &lt; 10 ?


.data
list:
	.word 1,2,3,4,5,6,7,8,9,10
</pre><p>Should be roughly equivalent to the following:</p><pre>int main (void)
{
	int list[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
	int idx = 1;
	int sum = *list;
	int r3;

	do {
		r3 = *(++list);
		sum += r3;
		idx += 1;
	} while (idx &lt; 10);

	return 0;
}
</pre><h2>First (runnable) program</h2><pre>.global _start

_start:
        MOV R0, #1 // stdout
        LDR R1, =message
        LDR R2, =len
        MOV R7, #4 // 4 is the write syscall code
        SWI 0

        MOV R7, #1 // 1 is the exit syscall code
        SWI 0

.data
message:
        .asciz &quot;hello world&quot;
len = .-message
</pre><p>Roughly equivalent to the following:</p><pre>int main (void)
{
	const char msg[] = &quot;hello world\n&quot;;
	write(1, msg, sizeof(msg));
	return 0;
}
</pre><h2>Constants</h2><pre>.global _start
.equ endlist, 0xaaaaaaaa

_start:
// ...
</pre><h2>QEMU</h2><p>At around 1h58min they show how to run an ARM VM in QEMU -- neat! Could be useful for other archs in the future.</p><h2>Compiling and linking</h2><pre>$ as foo.s -o foo.o
$ ld foo.o -o foo
</pre><h2>GDB</h2><p>Starting at around 2h22min they show some useful GDB functionality I didn&#39;t know about.</p><pre># Show in a TUI the CPU instructions around the current PC
&gt; layout asm

# Present in a TUI the register contents
&gt; layout regs
</pre><p>&lt;C-X&gt;&lt;C-O&gt; will jump between the GDB REPL and the other &quot;windows&quot;.</p></body></html>