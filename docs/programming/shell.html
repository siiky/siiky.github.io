<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html lang="en" xml:lang="en"><head><meta charset="utf-8"></meta></head><body><h1>RE: Misadventures with bash shell</h1><p>siiky<br></br>2022/08/01<br></br>2022/08/02</p><p>As StackSmith prompted:</p><blockquote>In the meantime, if you have a few minutes, write about why you love your shell.  I really want to know.</blockquote><ul><li><a href="https://portal.mozz.us/gemini/gemini.ctrl-c.club/~stack/gemlog/2022-08-01.bash.gmi">Misadventures with bash shell</a></li></ul><p>I don&#39;t love it, I even agree with some of the points raised, but after learning it one has to admit: most tasks are damn terse. And I can&#39;t imagine any Lisp-like syntax that could come even close -- BTW it&#39;s been tried at least once, that I know of:</p><ul><li><a href="https://scsh.net">Scsh</a></li><li><a href="https://en.wikipedia.org/wiki/Scsh">Scsh (Wikipedia)</a></li></ul><p>Maybe interesting, maybe not, but here are some of the features I use most often. I never know what&#39;s the right if/then syntax either, so when I want this:</p><pre>(when (file-exists? &quot;...&quot;)
  (do-this)
  (and-that))

(unless (file-exists? &quot;...&quot;)
  (do-this)
  (and-that))
</pre><p>I write this instead:</p><pre>[ -f &quot;...&quot; ] &amp;&amp; (do-this; do-that)

[ -f &quot;...&quot; ] || (do-this; do-that)
</pre><p>No more guessing where the hell the bang should go.</p><p>Loops all follow the same pattern:</p><pre>for/while/until ...; do ...; done
</pre><p>You can put the body of the loop in the background too, but obviously be careful not to forkbomb yourself.</p><pre>for/while/until ...; do ... &amp; done
</pre><p>Something I do often to start multiple terminals in the same Nix shell:</p><pre>exec nix-shell --run &#39;sh -c &quot;for i in {1..4}; do terminal &amp; done&quot;&#39; &amp;
</pre><p>The `exec ... &amp;` makes the nix-shell and child processes &quot;independent&quot;, so that I can continue to use the current terminal and/or close it without affecting the others. `for i in {1..4}` is equivalent to `for i in 1 2 3 4`. I think this syntax is relatively &quot;new&quot;; if you don&#39;t have it, you can use seq instead:</p><pre>for i in `seq 1 4`; do ...; done
</pre><p>Doing something for each line of input:</p><pre>some-command | while read line; do ...; done
</pre><p>read alone is a can of worms. It&#39;s very useful for simple things so worth knowing.</p><p>And some of the most important stuff: strings! There are 3 &quot;types&quot;: single quote, double quote, and backtick (plus $(...)). If you&#39;re unsure what type of string you need, go with single quotes because they&#39;re the safest and least surprising. If you need to interpolate values into your string, use double quote strings. If you need the result of a command as a string, use backticks (like the seq above). Backticks can be embedded in other string types.</p><pre>test=hello
echo &#39;hello world&#39;         # &quot;hello world&quot;
echo &#39;$test world&#39;         # &quot;$test world&quot;
echo &quot;$test world&quot;         # &quot;hello world&quot;
echo `echo &quot;$test world&quot;`  # &quot;hello world&quot;
echo $(echo &quot;$test world&quot;) # &quot;hello world&quot;
</pre><p>(I got some examples wrong as I was writing this haha)</p><p>In extreme cases, even though it&#39;s a mess to read, you can take advantage of automatic string concatenation to mix string types.</p><pre>echo &#39;a string with a single quote (&#39;&quot;&#39;&quot;&#39;)&#39;
echo &quot;a string with a double quote (&quot;&#39;&quot;&#39;&quot;)&quot;
</pre><p>I&#39;ve tried escaping in the past and failed too many times. This has never failed me once.</p><p>As a sort of conclusion: for some reason bash is one of the most, if not the most, popular interactive shell. Probably because it&#39;s the default in many Linux distros, especially the biggest ones. The default effect certainly worked with me because I&#39;m still &quot;stuck&quot; with it. But bash isn&#39;t the only one out there, so if you don&#39;t like it, do yourself a favor and try a different one! Some shells I can think of: fish, zsh, ksh, ion (of RedoxOS), csh.</p><p>As for me, I&#39;ve read my share of shit-throwing at bash, but it&#39;s been working OK. I don&#39;t need the fancy features offered by fish or zsh. If I tried any new interactive shell, it&#39;d probably by zsh or ion.</p></body></html>