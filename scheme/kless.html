<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="siiky" />
  <title>kless</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    q { quotes: "“" "”" "‘" "’"; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <style type="text/css">
body {
background-color:#101010;
color:#FD971F;
font-family:monospace;
font-size:15px;

}
h1,h2,h3,h4,h5,h6 {
color:#A6E22E;
text-decoration:bold;
}
h1 { font-size:21px; }
h2 { font-size:20px; }
h3 { font-size:19px; }
h4 { font-size:18px; }
h5 { font-size:17px; }
h6 { font-size:16px; }
a {
color:#66D9EF;
text-decoration:none
}
a:visited {
color:#A6E22E
}
a:hover {
background-color:#66D9EF;
color:#101010;
text-decoration:underline
}
</style>
</head>
<body>
<header id="title-block-header">
<h1 class="title"><code>kless</code></h1>
<p class="author">siiky</p>
<p class="date">2019/10/13</p>
</header>
<p>I read recently a blog post called <a href="https://www.winestockwebdesign.com/Essays/Lisp_Curse.html"><em>The Lisp Curse</em></a> (not yet HTTPS enabled, but hoping it will be in the future). In this post, the author, Rudolf Winestock, says that <q>Making Scheme object-oriented is a sophomore homework assignment</q>; and so, for fun, I tried hacking an abstraction for defining classes in Scheme, with the little knowledge of macros that I have.</p>
<h1 data-number="1" id="implementation"><span class="header-section-number">1</span> Implementation</h1>
<p>Below is the definition of the <code>kless</code> macro.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scm"><code class="sourceCode scheme"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="co">;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="co">;!! Read identifiers with Metalocalypse Pickles&#39; accent !!!</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="co">;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>(<span class="ex">define-syntax</span><span class="fu"> kless</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  <span class="co">; `meth` is a reserved keyword inside the macro, i.e., it has a special</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  <span class="co">; meaning and you can&#39;t name a kless or method &quot;meth&quot;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  (<span class="kw">syntax-rules</span> (meth)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>    <span class="co">;; TEMPLATE</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    ((kless</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>       (kless-name ver-name ...)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>       (meth (meth-name meth-args ...)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>             meth-body ...) ...)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>     <span class="co">;; RESULT</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>     (<span class="kw">begin</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>       <span class="co">; If your Scheme of choice doesn&#39;t support curried definitions</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>       <span class="co">; use lambda instead:</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>       <span class="co">;   (define (kless-name ver-name ...)</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>       <span class="co">;     (lambda (method self . args)</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>       (<span class="ex">define</span><span class="fu"> </span>((kless-name ver-name ...) method self . args)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>         (<span class="ex">define</span><span class="fu"> </span>(err sym)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>           (error (<span class="kw">string-append</span> <span class="st">&quot;&#39;&quot;</span> (<span class="kw">symbol-&gt;string</span> sym) <span class="st">&quot;&#39;? dat shiet dun exist yo&quot;</span>)))</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true"></a>         (<span class="ex">define</span><span class="fu"> </span>(getter ver)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true"></a>           (<span class="kw">case</span> ver</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true"></a>             ((ver-name) ver-name) ...</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true"></a>             (<span class="kw">else</span> (err ver))))</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true"></a>         (<span class="ex">define</span><span class="fu"> </span>(setter ver val)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true"></a>           (<span class="kw">case</span> ver</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true"></a>             ((ver-name) (set! ver-name val)) ...</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true"></a>             (<span class="kw">else</span> (err ver))))</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true"></a></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true"></a>         <span class="co">;; Dispatch</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true"></a>         (<span class="kw">case</span> method</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true"></a>           ((get) (apply getter args))</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true"></a>           ((set) (apply setter args))</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true"></a>           ((meth-name)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true"></a>            (apply (<span class="kw">lambda</span> (meth-args ...)</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true"></a>                     meth-body ...)</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true"></a>                   args)) ...</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true"></a>           (<span class="kw">else</span> (err method))))</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true"></a></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true"></a>       <span class="co">;; [GS]etters</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true"></a>       (<span class="ex">define</span><span class="fu"> </span>(ver-name self . val)</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true"></a>         (<span class="kw">if</span> (<span class="kw">null?</span> val)</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true"></a>             (self &#39;get self &#39;var-name)</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true"></a>             (self &#39;set self &#39;var-name (<span class="kw">car</span> val)))) ...</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true"></a></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true"></a>       <span class="co">;; Custom methods</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true"></a>       (<span class="ex">define</span><span class="fu"> </span>(meth-name self meth-args ...)</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true"></a>         (self &#39;meth-name self meth-args ...)) ...))))</span></code></pre></div>
<p>With <code>kless</code> you can specify instance variables, with getters and destructive setters automatically defined for you, and instance (non-static) methods. Because the methods’ bodies are inserted into the object itself, instance variables are in scope, and no extra magic is needed for making them available.</p>
<p>Having two classes with methods (or variables, for that matter) of the same name results in two functions with exactly the same names and bodies being defined. By defining the two classes above (<code>dek</code> and <code>blenk-dek</code>), <code>show-me</code> is defined twice, like so:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scm"><code class="sourceCode scheme"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(show-me self)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  (self &#39;show-me self))</span></code></pre></div>
<p>This is OK in Scheme, so dick-typing (a la Python) is supported.</p>
<h1 data-number="2" id="example-klesses"><span class="header-section-number">2</span> Example <code>kless</code>es</h1>
<p>The following example shows that/how <code>kless</code> works, and what OO is good for.</p>
<p>Defining two classes:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scm"><code class="sourceCode scheme"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="co">;; Very important dek class! It is used to represent various types of deks</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>(kless (dek x y)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>       (meth (show-me)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>             (print <span class="st">&quot;8&quot;</span> (<span class="kw">make-string</span> x <span class="ch">#\=</span>) <span class="st">&quot;D&quot;</span> (<span class="kw">make-string</span> y <span class="ch">#\~</span>))))</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>(kless (blenk-dek x)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>       (meth (show-me)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>             (print <span class="st">&quot;8&quot;</span> (<span class="kw">make-string</span> x <span class="ch">#\=</span>) <span class="st">&quot;D&quot;</span>)))</span></code></pre></div>
<p>Inspecting generated procedures and trying things out with <code>csi</code> (the CHICKEN Scheme Interpreter):</p>
<pre><code>#;1&gt; dek
#&lt;procedure (dek x y)&gt;
#;2&gt; blenk-dek
#&lt;procedure (blenk-dek x)&gt;
#;3&gt; x
#&lt;procedure (x self270 . val282)&gt;
#;4&gt; y
#&lt;procedure (y self204 . val216)&gt;
#;5&gt; show-me
#&lt;procedure (show-me self270)&gt;
#;6&gt; (show-me (dek 2 4))
8==D~~~~
#;7&gt; (show-me (blenk-dek 4))
8====D</code></pre>
<h1 data-number="3" id="thorns"><span class="header-section-number">3</span> Thorns</h1>
<p><code>self</code> is not in scope (or rather, <code>self</code>, the object itself, is in scope, but is not called <code>self</code> because of <code class="sourceCode scheme"><span class="kw">syntax-rules</span></code> magic). Recursive methods are still possible, with a named-<code class="sourceCode scheme"><span class="kw">let</span></code> or <code class="sourceCode scheme"><span class="ex">define</span></code>. Just don’t use other methods.</p>
<p>No type predicate is defined, but can be easily implemented.</p>
<p>No hierarchy, inheritance, no nothing!</p>
<p>No <q>static</q> class methods. Because, what? Just make a function, prefix it with the class name and be done with it.</p>
<p>No extending already defined classes, a la Haskell’s type classes (with <code class="sourceCode haskell"><span class="kw">instance</span> <span class="op">...</span> <span class="kw">where</span></code>), or Rust’s traits (with <code class="sourceCode rust"><span class="kw">impl</span></code>). Put everything inside <code>kless</code> and dick-typing does the rest.</p>
<p>Method overriding on a per object basis is not possible. This may be easy to implement. One way is to put a table inside the object, from method name to procedure (<code class="sourceCode haskell"><span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">Method</span></code>), and arrange a way to get and set that procedure from outside the object. A problem arises then: this new method doesn’t have the instance variables in scope. One could be tempted to think that something like the following solves the problem.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scm"><code class="sourceCode scheme"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>(<span class="ex">define</span><span class="fu"> </span>(meth-setter meth-name meth-maker)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  (update-meth-table meth-name (meth-maker ver-name ...)))</span></code></pre></div>
<p>This would indeed bring the current variables into scope, but not future updates, as this new method’s scope is not the same as the object’s scope itself. (There was also something similar on <a href="https://letoverlambda.com"><em>Let Over Lambda</em></a> IIRC)</p>
<p>Another option would be to have another indirection for the actual method’s code, such that the current instance variables are given on each call. Calling one such method would be something like:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scm"><code class="sourceCode scheme"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>(((<span class="kw">lambda</span> (ver-name ...)    <span class="co">; instance variables</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>    (<span class="kw">lambda</span> (meth-args ...) <span class="co">; method parameters</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>      meth-body ...))       <span class="co">; method body</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>  ver-name ...)             <span class="co">; get the method procedure, with instance variables in scope</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a> meth-args ...)             <span class="co">; call the methodd</span></span></code></pre></div>
<div class="line-block">places:<br />
<a href="https://siiky.github.io">Go home!</a><br />
<a href="https://github.com/siiky">GitHub</a><br />
<a href="https://siiky.github.io/atom.xml">Atom Feed</a></div>
</body>
</html>
